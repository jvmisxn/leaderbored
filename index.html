<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeaderBored - Friendly Competition Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
html {
    height: 100%; /* Ensure the root element takes full height */
}

/* --- Theme Color Variables --- */
:root {
  /* --- Light Mode: Blue & White --- */
  --bg-color-light: #f3f4f6;           /* White background */
  --text-color-light: #1e40af;         /* Dark Blue text (like Tailwind blue-800) */
  --accent-bg-light: #2563eb;        /* Medium Blue accent background (like blue-600) */
  --accent-text-light: #ffffff;       /* White text on blue accents */
  --card-bg-light: #ffffff;           /* White card background */
  --text-muted-light: #6b7280;       /* Gray for muted text */
  --link-color-light: #1d4ed8;         /* Medium-Dark Blue links (like blue-700) */
  --border-color-light: #dbeafe;       /* Light Blue border (like blue-200) */

  /* --- Dark Mode: Red & Black --- */
  --bg-color-dark: #111827;           /* Black background */
  --text-color-dark: #ef4444;         /* Medium Red text (like red-500) */
  --accent-bg-dark: #dc2626;        /* Medium-Dark Red accent background (like red-600) */
  --accent-text-dark: #ffffff;       /* White text on red accents (Adjust if contrast needed) */
  --card-bg-dark: #1f2937;           /* Very Dark Gray/Off-black card background */
  --text-muted-dark: #9ca3af;       /* Light gray for muted text */
  --link-color-dark: #f87171;         /* Lighter Red links (like red-400) */
  --border-color-dark: #7f1d1d;       /* Dark Red border (like red-900) */
}

/* --- Base Body Styles --- */
body {
    font-family: 'Inter', sans-serif;
    min-height: 100vh; /* Full viewport height */
    background-color: var(--bg-color-light);
    color: var(--text-color-light);
    /* Removed gradient, using solid color */
    background-attachment: fixed;
    background-repeat: no-repeat;
    background-size: cover;
}
a, button, .player-entry { transition: all 0.2s ease-in-out; }
.timer-display { font-size: 2.5rem; font-weight: bold; margin-bottom: 1rem; }
        .dice-result { font-size: 3rem; margin: 1rem 0; font-weight: bold; }
        .score-input { width: 60px; text-align: center; }

        /* --- NEW: Styles for Play Dropdown Dark Mode --- */
         body.dark #play-dropdown {
             background-color: var(--card-bg-dark); /* Use dark card background */
             --tw-ring-opacity: 1;
             --tw-ring-color: rgba(75, 85, 99, var(--tw-ring-opacity)); /* Example: gray-500 */
         }
          /* Style links within the PLAY dropdown */
          body.dark #play-dropdown a {
              color: var(--text-muted-dark); /* Use muted text color */
          }
          body.dark #play-dropdown a:hover {
              background-color: #374151; /* Example: Darker gray hover */
              color: var(--accent-text-dark); /* Use accent text color (white) */
          }
        /* --- Make sure Play dropdown has base transition styles --- */
        #play-dropdown {
             transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }
        #play-dropdown.hidden {
             opacity: 0; transform: translateY(-10px); pointer-events: none;
        }
/* --- Visibility Control --- */
/* Admin */
.admin-only { display: none; }
body.admin-logged-in #tournament-detail-content .admin-only { display: inline-block; }
body.admin-logged-in td .admin-only { display: inline-flex; gap: 0.5rem; vertical-align: middle; }
body.admin-logged-in #player-info-modal .admin-only { display: block; }
body.admin-logged-in .contextual-admin-button-container .admin-only { display: inline-flex; }
body.admin-logged-in .public-only { display: none; }
/* Player */
.player-only { display: none; }
.player-public-only { display: inline-flex; }
body.player-logged-in .player-only { display: inline-flex; }
body.player-logged-in .player-public-only { display: none; }
/* Combined Logins */
body.player-logged-in .admin-public-only { display: none; }
body.admin-logged-in .player-public-only { display: none; }

/* --- Layout & Components --- */
/* Dropdown */
#profile-dropdown { transition: opacity 0.2s ease-out, transform 0.2s ease-out; }
#profile-dropdown.hidden { opacity: 0; transform: translateY(-10px); pointer-events: none; }
/* Modals */
.modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
.modal-overlay.active { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
.modal-content { background-color: var(--card-bg-light); padding: 1.5rem 2rem 2rem 2rem; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); max-width: 95%; width: 550px; max-height: 90vh; overflow-y: auto; position: relative; transform: translateY(-20px) scale(0.98); transition: transform 0.3s ease, opacity 0.3s ease; opacity: 0; }
.modal-overlay.active .modal-content { transform: translateY(0) scale(1); opacity: 1; }
.modal-close-button { position: absolute; top: 0.5rem; right: 0.75rem; background: none; border: none; font-size: 1.75rem; font-weight: bold; color: var(--text-muted-light); cursor: pointer; padding: 0.25rem; line-height: 1; }
.modal-close-button:hover { color: var(--text-color-light); }
/* Ranking Table */
.ranking-table { display: none; }
.ranking-table.active { display: block; }
/* Multi-select (if used) */
.multi-select-list { max-height: 150px; overflow-y: auto; border: 1px solid var(--border-color-light); border-radius: 0.375rem; padding: 0.5rem; background-color: #f9fafb; } /* Consider a light variable for bg */
/* Table Cells */
td, th { white-space: nowrap; padding-left: 1rem; padding-right: 1rem; padding-top: 0.75rem; padding-bottom: 0.75rem; vertical-align: middle; }
td { white-space: normal; }
/* Validation */
.border-red-500 { border-color: #ef4444; }
/* Player Modal Edit Mode */
.modal-editing .editable-field { display: none; }
.modal-editing .editing-field { display: block; }
.editing-field { display: none; }
.modal-editing .edit-mode-controls { display: inline-flex; }
.edit-mode-controls { display: none; }
.modal-editing .view-mode-controls { display: none; }
/* Tournament Detail Section */
#tournament-detail-section.loading #tournament-detail-content { display: none; }
#tournament-detail-section.loading #tournament-detail-loading { display: block; }
#tournament-detail-section:not(.loading) #tournament-detail-loading { display: none; }
#tournament-detail-section.error #tournament-detail-content { display: none; }
#tournament-detail-section.error #tournament-detail-error { display: block; }
#tournament-detail-section:not(.error) #tournament-detail-error { display: none; }
#tournament-detail-loading, #tournament-detail-error { display: none; }

/* --- Base Element Light Mode Styles (Using Variables) --- */
nav { /* Default nav style */
    background-image: none;
    background-color: var(--accent-bg-light); /* Blue */
    color: var(--accent-text-light); /* White */
    /* Add padding, shadow, sticky etc. back if needed, or handle with Tailwind classes */
    padding: 1.25rem; /* p-5 */
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1); /* shadow-lg */
    position: sticky; top: 0; z-index: 50;
}
.bg-white { background-color: var(--card-bg-light); } /* Handles cards etc. */
h1, h2, h3, .text-gray-900, .text-gray-800 { color: var(--text-color-light); } /* Headings & primary text */
.text-gray-700, .text-gray-600, .text-gray-500 { color: var(--text-muted-light); } /* Muted text */
a, .text-blue-600 { color: var(--link-color-light); } /* Links */
a:hover, .text-blue-600:hover { text-decoration: underline; color: #1e40af; /* Darker blue hover */ }
.border-blue-200 { border-color: var(--border-color-light); } /* Borders */
.bg-gray-100 { background-color: #f3f4f6; } /* Light gray background (e.g., table header) - consider removing if theme is pure blue/white */
.text-indigo-700 { color: var(--link-color-light); } /* Use link color for indigo text */
footer { color: var(--text-muted-light); }

/* --- Dark Mode Overrides --- */
body.dark {
  background-color: var(--bg-color-dark);
  color: var(--text-color-dark);
  /* background-image: none; /* Solid background for dark mode */ */
}

/* Dark Nav */
body.dark nav {
    background-image: none;
    background-color: var(--accent-bg-dark); /* Red */
    color: var(--accent-text-dark); /* White or Black */
}
/* Ensure nav links are readable */
body.dark nav a {
     color: var(--accent-text-dark);
}
/* Optional: Dark nav link hover */
body.dark nav a:hover {
    color: #f3f4f6; /* Example: Light gray hover */
    text-decoration: none;
}
body.dark nav .group .bg-white {
     background-color: var(--card-bg-dark); /* Use dark card background */
     /* Optional: Adjust ring/border for better visibility */
     --tw-ring-opacity: 1;
     --tw-ring-color: rgba(75, 85, 99, var(--tw-ring-opacity)); /* Example: gray-500 */
 }
 /* Style links within the general nav dropdowns */
 body.dark nav .group .bg-white a {
     color: var(--text-muted-dark); /* Use muted text color for dark mode */
 }
 body.dark nav .group .bg-white a:hover {
     background-color: #374151; /* Example: Darker gray hover */
     color: var(--accent-text-dark); /* Use accent text color (white) on hover */
 }

 /* Target the profile dropdown menu specifically */
 body.dark #profile-dropdown {
     background-color: var(--card-bg-dark); /* Use dark card background */
     /* Optional: Adjust ring/border */
      --tw-ring-opacity: 1;
     --tw-ring-color: rgba(75, 85, 99, var(--tw-ring-opacity)); /* Example: gray-500 */
 }
  /* Style links within the profile dropdown */
  body.dark #profile-dropdown a {
      color: var(--text-muted-dark); /* Use muted text color */
  }
  body.dark #profile-dropdown a:hover {
      background-color: #374151; /* Example: Darker gray hover */
      color: var(--accent-text-dark); /* Use accent text color (white) */
  }

body.dark .bg-white { background-color: var(--card-bg-dark); }
/* Dark Cards / White Backgrounds */
body.dark .bg-white { background-color: var(--card-bg-dark); }
/* Dark Headings & Primary Text */
body.dark h1, body.dark h2, body.dark h3,
body.dark .text-gray-900, body.dark .text-gray-800 { color: var(--text-color-dark); }
/* Dark Muted Text */
body.dark .text-gray-700, body.dark .text-gray-600, body.dark .text-gray-500 { color: var(--text-muted-dark); }
/* Dark Links */
body.dark a, body.dark .text-blue-600 { color: var(--link-color-dark); }
body.dark a:hover, body.dark .text-blue-600:hover { color: #ef4444; /* Medium Red hover */ }
/* Dark Borders */
body.dark .border-blue-200 { border-color: var(--border-color-dark); }
/* Dark Light Gray Background */
body.dark .bg-gray-100 { background-color: #1f2937; } /* Very Dark Gray */
/* Dark Indigo Text */
body.dark .text-indigo-700 { color: var(--link-color-dark); }
/* Dark Modals */
body.dark .modal-content { background-color: var(--card-bg-dark); }
body.dark .modal-close-button { color: var(--text-muted-dark); }
body.dark .modal-close-button:hover { color: var(--text-color-dark); }
/* Dark Footer */
body.dark footer { color: var(--text-muted-dark); }

/* Dark Form Select */
body.dark select,
body.dark #rankings-game-filter {
    background-color: #1f2937; /* Match dark card background */
    color: #f3f4f6;           /* Light text */
    border-color: #4b5563;    /* Darker border */
}
/* Dark Multi-select list */
body.dark .multi-select-list {
    background-color: #111827; /* Even darker background */
    border-color: #4b5563;
}

/* Dark Mode Specific Text Colors (from previous overrides) */
body.dark .text-green-600 { color: #34d399; } /* Keep green for wins? */
body.dark .text-red-600 { color: #f87171; }   /* Use theme link color? */
body.dark .text-indigo-600 { color: var(--link-color-dark); } /* Use theme link color */

/* --- Dark Mode Toggle Switch --- */
input:checked ~ .dot { transform: translateX(100%); background-color: var(--link-color-dark); /* Use Red for "on" in dark mode? */ }
input:checked ~ .block { background-color: #4b5563; /* Darker track */ }
/* Label text (already handled by footer rule) */
/* .dark .dark\:text-gray-300 { color: var(--text-muted-dark); } */

    </style>
</head>
<body>
    <nav class="bg-gradient-to-r from-cyan-600 to-blue-700 text-white p-5 shadow-lg sticky top-0 z-50 flex items-center justify-between">

        <a href="#home-section" class="text-xl font-bold nav-link flex-shrink-0" data-target="home-section">üèÜ LeaderBored</a>

        <div class="flex items-center space-x-4">
            <div class="relative group">
                <button class="hover:text-blue-100 px-3 py-2 rounded-md text-base font-medium focus:outline-none flex items-center">
                    PLAY <svg class="w-4 h-4 ml-1 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                </button>
                <div id="play-dropdown" class="absolute left-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
                    <a href="#live-game-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="live-game-section" role="menuitem">PLAY LIVE GAME</a>
                    <a href="#submit-past-game-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="submit-past-game-section" role="menuitem">SUBMIT PAST GAME</a>
                </div>
            </div>
            <div class="relative group">
                <button class="hover:text-blue-100 px-3 py-2 rounded-md text-base font-medium focus:outline-none flex items-center">
                    INFO <svg class="w-4 h-4 ml-1 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                </button>
                <div class="absolute left-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
                    <a href="#players-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="players-section" role="menuitem">PLAYERS</a>
                    <a href="#rankings-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="rankings-section" role="menuitem">RANKINGS</a>
                    <a href="#results-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="results-section" role="menuitem">GAMES</a>
                    <a href="#sports-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="sports-section" role="menuitem">SPORTS</a>
                </div>
            </div>

            <div class="relative group">
                <button class="hover:text-blue-100 px-3 py-2 rounded-md text-base font-medium focus:outline-none flex items-center">
                    TOURNAMENTS <svg class="w-4 h-4 ml-1 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                </button>
                <div class="absolute left-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
                    <a href="#tournaments-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="tournaments-section" role="menuitem">HISTORY</a>
                    <a href="#tournaments-section" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 nav-link" data-target="tournaments-section" role="menuitem">UPCOMING</a>
                </div>
            </div>
        </div>

        <div class="flex items-center space-x-4 flex-shrink-0"> <a href="#player-login-section" id="player-login-link" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg text-sm font-medium shadow hover:shadow-md public-only player-public-only nav-link" data-target="player-login-section">Login</a>

            <div id="profile-section" class="relative player-only">
                <button id="profile-photo-button" class="block h-10 w-10 rounded-full overflow-hidden border-2 border-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-blue-700 focus:ring-white">
                    <img id="profile-photo-img" src="https://ui-avatars.com/api/?name=?&background=E0E7FF&color=4F46E5&size=40" alt="My Profile" class="h-full w-full object-cover">
                </button>
                <div id="profile-dropdown" class="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden" role="menu" aria-orientation="vertical" aria-labelledby="profile-photo-button">
                    <a href="#" id="dropdown-edit-profile" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Edit Profile</a>
                    <a href="#" id="dropdown-settings" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Settings</a>
                    <a href="#" id="dropdown-logout" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Logout</a>
                </div>
            </div>
        </div>

    </nav>

    <div class="container mx-auto mt-8 p-6">
        <section id="home-section" class="page-section space-y-8">
             <h1 class="text-4xl font-bold text-gray-900 border-b-2 border-blue-200 pb-3 mb-6">Dashboard</h1>
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                 <div class="bg-white p-8 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300">
                     <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Recent Games</h2>
                     <ul id="recent-games-list" class="space-y-4 text-base">
                         <li class="text-gray-500">Loading recent games...</li>
                     </ul>
                     <a href="#results" class="text-blue-600 hover:underline mt-5 inline-block font-medium nav-link" data-target="results-section">View all results...</a>
                 </div>
                 <div class="bg-white p-8 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300">
                     <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Top Players (Overall)</h2>
                     <ol id="top-players-list" class="list-decimal list-inside space-y-3 text-base">
                         <li class="text-gray-500">Loading rankings...</li>
                     </ol>
                     <a href="#rankings" class="text-blue-600 hover:underline mt-5 inline-block font-medium nav-link" data-target="rankings-section">View full rankings...</a>
                 </div>
                 <div class="bg-white p-8 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300">
                     <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Top Teams (Overall)</h2>
                     <ol id="top-teams-list" class="list-decimal list-inside space-y-3 text-base">
                         <li class="text-gray-500">Loading rankings...</li>
                     </ol>
                     <a href="#rankings" class="text-blue-600 hover:underline mt-5 inline-block font-medium nav-link" data-target="rankings-section">View full rankings...</a>
                 </div>
                 <div class="bg-white p-8 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300 md:col-span-2 lg:col-span-1">
                     <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Tournaments</h2>
                     <ul id="dashboard-tournaments-list" class="space-y-4">
                         <li class="text-gray-500">Loading tournaments...</li>
                     </ul>
                     <a href="#tournaments" class="text-blue-600 hover:underline mt-5 inline-block font-medium nav-link" data-target="tournaments-section">View all tournaments...</a>
                 </div>
             </div>
        </section>

        <section id="rankings-section" class="page-section hidden space-y-8">
             <div class="flex justify-between items-center border-b-2 border-blue-200 pb-3 mb-6 flex-wrap gap-4"> <h1 class="text-4xl font-bold text-gray-900">Rankings</h1>
                 <div class="flex items-center gap-4 flex-wrap"> <div>
                         <label for="rankings-game-filter" class="text-sm font-medium text-gray-700 mr-2">Filter by Game:</label>
                         <select id="rankings-game-filter" name="rankings-game-filter" class="shadow-sm border border-gray-300 rounded-lg py-2 px-3 text-base focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500">
                             <option value="overall">Overall (1v1/2v2)</option>
                             </select>
                     </div>
                     <div class="contextual-admin-button-container">
                         <button id="open-add-game-modal-btn" class="admin-only bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow hover:shadow-md focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 text-sm">
                             ‚öôÔ∏è Add New Game Type
                         </button>
                     </div>
                 </div>
             </div>
             <div id="ranking-tables-container">
                 <div id="ranking-table-overall" class="ranking-table active grid grid-cols-1 md:grid-cols-2 gap-8">
                     <div class="bg-white p-8 rounded-xl shadow-lg">
                         <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Overall 1v1 Rankings (Elo)</h2>
                         <table class="w-full text-left table-auto text-base">
                             <thead> <tr class="bg-gray-100"> <th class="px-4 py-3">Rank</th> <th class="px-4 py-3">Player</th> <th class="px-4 py-3">Rating</th> </tr> </thead>
                             <tbody id="overall-1v1-rankings-body"> <tr class="border-b"><td colspan="3" class="text-center text-gray-500 py-4">Loading...</td></tr> </tbody>
                         </table>
                     </div>
                     <div class="bg-white p-8 rounded-xl shadow-lg">
                         <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Overall 2v2 Team Rankings (Elo)</h2>
                         <table class="w-full text-left table-auto text-base">
                             <thead> <tr class="bg-gray-100"> <th class="px-4 py-3">Rank</th> <th class="px-4 py-3">Team</th> <th class="px-4 py-3">Rating</th> </tr> </thead>
                             <tbody id="overall-2v2-rankings-body"> <tr class="border-b"><td colspan="3" class="text-center text-gray-500 py-4">Loading...</td></tr> </tbody>
                         </table>
                     </div>
                 </div>
                 </div>
        </section>
        <section id="sports-section" class="page-section hidden space-y-8">
            <h1 class="text-4xl font-bold text-gray-900 border-b-2 border-blue-200 pb-3 mb-6">Sports Overview</h1>
 
            <div id="sports-gallery" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300">
                    <h2 class="text-2xl font-semibold mb-3 text-indigo-700">Golf</h2>
                    <p class="text-sm text-gray-600 mb-4">Track scores, handicaps, and course performance.</p>
                    <button data-sport="golf" class="view-sport-details-btn text-blue-600 hover:underline font-medium">View Details & Courses</button>
                </div>
                <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300">
                     <h2 class="text-2xl font-semibold mb-3 text-indigo-700">Pool</h2>
                     <p class="text-sm text-gray-600 mb-4">View player rankings and recent match results.</p>
                     <button data-sport="pool" class="view-sport-details-btn text-blue-600 hover:underline font-medium">View Rankings</button> </div>
                 <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300">
                     <h2 class="text-2xl font-semibold mb-3 text-indigo-700">Overall</h2>
                     <p class="text-sm text-gray-600 mb-4">See combined 1v1 and 2v2 rankings.</p>
                     <button data-sport="overall" class="view-sport-details-btn text-blue-600 hover:underline font-medium">View Rankings</button> </div>
                <div class="col-span-full text-center text-gray-500 p-4">
                     </div>
            </div>
 
            <div id="golf-details-view" class="hidden space-y-6 mt-10">
                <div class="flex justify-between items-center border-b-2 border-blue-200 pb-3 mb-6">
                    <h2 class="text-3xl font-bold text-gray-900">Golf Details</h2>
                     <button id="back-to-sports-gallery-btn" class="text-blue-600 hover:underline">&larr; Back to Sports Overview</button>
                </div>
                <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
                    <h3 class="text-xl font-semibold mb-2 text-indigo-600">About Golf</h3>
                    <p class="text-gray-700 mb-4 text-sm">
                        Golf is a club-and-ball sport in which players use clubs to hit balls into a series of holes on a course in as few strokes as possible. It requires precision, strategy, and mental focus. Players navigate varied terrain, manage different club selections, and adhere to a comprehensive set of rules governing play.
                    </p>
                    <button id="show-golf-rules-btn" class="text-white bg-blue-600 hover:bg-blue-700 font-medium rounded-lg text-sm px-5 py-2.5 focus:outline-none">
                        View Official Rules
                    </button>
                </div>
                <div class="text-right contextual-admin-button-container">
                     <button id="open-add-course-modal-btn" class="admin-only bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow hover:shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                         ‚õ≥ Add New Course
                     </button>
                </div>
                <div id="golf-rules-modal" class="modal-overlay">
                    <div class="modal-content" style="width: 90%; max-width: 1000px;"> <button id="close-golf-rules-modal-btn" class="modal-close-button">&times;</button>
                        <h2 class="text-2xl font-semibold mb-4 text-indigo-700">Official Rules of Golf (The R&A)</h2>
                        <div class="border rounded-lg overflow-hidden">
                          <iframe id="golf-rules-iframe" src="about:blank" width="100%" height="70vh" frameborder="0" title="Official Rules of Golf">
                              Loading Rules...
                          </iframe>
                        </div>
                         <p class="text-xs text-gray-500 mt-2">Rules provided by <a href="https://www.randa.org/en/rog/the-rules-of-golf" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">The R&A</a>.</p>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-semibold mb-4 text-indigo-600">Courses</h3>
                    <div id="golf-courses-list" class="space-y-4">
                        <p class="text-gray-500">Loading courses...</p>
                    </div>
                </div>
 
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-semibold mb-4 text-indigo-600">Recent Golf Scores</h3>
                    <div id="golf-results-list" class="space-y-2">
                         <p class="text-gray-500">Loading results...</p>
                    </div>
                 </div>
            </div>
 
       </section>
        <section id="results-section" class="page-section hidden space-y-8">
            <div class="flex justify-between items-center border-b-2 border-blue-200 pb-3 mb-6">
                 <h1 class="text-4xl font-bold text-gray-900">All Game Results</h1>
                 <div class="contextual-admin-button-container">
                    <button id="open-record-game-modal-btn" class="admin-only bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow hover:shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                        üèÜ Record Game Result
                    </button>
                 </div>
            </div>
            <div class="bg-white p-6 rounded-xl shadow-lg overflow-x-auto">
                <table class="w-full text-left table-auto text-base">
                    <thead>
                        <tr class="bg-gray-100">
                            <th class="px-4 py-3">Date</th>
                            <th class="px-4 py-3">Game Type</th>
                            <th class="px-4 py-3">Description</th>
                            <th class="px-2 py-3 text-center w-10">‚öôÔ∏è</th>
                        </tr>
                    </thead>
                    <tbody id="results-table-body">
                         <tr><td colspan="4" class="text-gray-500 text-center py-4">Loading results...</td></tr>
                    </tbody>
                </table>
            </div>
        </section>
        <section id="pool-page" class="page-section hidden space-y-8">
            <div class="flex justify-between items-center border-b-2 border-blue-200 pb-3 mb-6">
                 <h1 class="text-3xl font-bold text-gray-900">Pool (Billiards)</h1>
                 <a href="#sports-section" data-target="sports-section" class="nav-link text-blue-600 hover:underline">&larr; Back to Sports Overview</a>
            </div>

            <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
                <h3 class="text-xl font-semibold mb-2 text-indigo-600">About Pool</h3>
                <p class="text-gray-700 mb-4 text-sm">
                    Pool, a category of cue sports, involves striking a cue ball to pocket object balls into designated pockets. Popular variations include Eight-ball, Nine-ball, and Straight Pool, each with specific rules and objectives. It demands precision, strategy, and control over the cue ball's position.
                </p>
                <a href="https://wpapool.com/rules/" target="_blank" rel="noopener noreferrer" class="inline-block text-white bg-blue-600 hover:bg-blue-700 font-medium rounded-lg text-sm px-5 py-2.5 focus:outline-none">
                    View Official WPA Rules
                </a>
            </div>

             <div class="bg-white p-8 rounded-xl shadow-lg">
                 <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Pool Rankings (Elo)</h2>
                 <table class="w-full text-left table-auto text-base">
                     <thead>
                         <tr class="bg-gray-100">
                             <th class="px-4 py-3">Rank</th>
                             <th class="px-4 py-3">Player</th>
                             <th class="px-4 py-3">Rating</th>
                         </tr>
                     </thead>
                     <tbody id="pool-rankings-body">
                         <tr><td colspan="3" class="text-center text-gray-500 py-4">Loading rankings...</td></tr>
                         </tbody>
                 </table>
            </div>

            <div class="bg-white p-8 rounded-xl shadow-lg">
                 <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Recent Pool Results</h2>
                 <div id="pool-results-list" class="space-y-2">
                     <p class="text-gray-500">Loading results...</p>
                     </div>
             </div>

            </section>
        <section id="players-section" class="page-section hidden space-y-8">
             <div class="flex justify-between items-center border-b-2 border-blue-200 pb-3 mb-6">
                 <h1 class="text-4xl font-bold text-gray-900">Players</h1>
                 <div class="contextual-admin-button-container">
                     <button id="open-add-player-modal-btn" class="admin-only bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow hover:shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                         ‚ûï Add New Player
                     </button>
                 </div>
             </div>
             <div id="players-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                 <p class="text-gray-500 col-span-full text-center">Loading players...</p>
             </div>
        </section>

        <section id="tournaments-section" class="page-section hidden space-y-8">
             <div class="flex justify-between items-center border-b-2 border-blue-200 pb-3 mb-6">
                 <h1 class="text-4xl font-bold text-gray-900">Tournaments</h1>
                  <div class="contextual-admin-button-container">
                    <button id="open-create-tournament-modal-btn" class="admin-only bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow hover:shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        ‚ûï Create New Tournament
                    </button>
                 </div>
             </div>
             <div class="bg-white p-8 rounded-xl shadow-lg">
                 <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Tournament List</h2>
                 <div id="tournaments-list-full" class="space-y-6">
                     <p class="text-gray-500">Loading tournaments...</p>
                 </div>
             </div>
             </section>

             <section id="tournament-detail-section" class="page-section hidden space-y-8">
                <div id="tournament-detail-loading" class="text-center py-10">
                     <p class="text-gray-500 text-lg">Loading tournament details...</p>
                 </div>
                 <div id="tournament-detail-error" class="text-center py-10">
                     <p class="text-red-600 text-lg">Error loading tournament details.</p>
                     <p id="tournament-detail-error-message" class="text-red-500 text-sm mt-1"></p>
                 </div>
                 <div id="tournament-detail-content">
                     <div class="flex justify-between items-center border-b-2 border-blue-200 pb-3 mb-6">
                         <h1 class="text-4xl font-bold text-gray-900">Tournament: <span id="tournament-detail-name">[Tournament Name]</span></h1>
                         <a href="#tournaments" class="text-blue-600 hover:underline nav-link" data-target="tournaments-section">&larr; Back to Tournaments</a>
                     </div>
    
                    <div class="admin-only mb-6 text-right space-x-3">
                         <button id="edit-tournament-detail-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow hover:shadow-md text-sm">
                             Edit Tournament
                         </button>
                         <button id="delete-tournament-detail-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow hover:shadow-md text-sm">
                             Delete Tournament
                         </button>
                     </div>
    
                     <div class="bg-white p-8 rounded-xl shadow-lg">
                        <p class="text-lg mb-1"><strong>Game:</strong> <span id="tournament-detail-game">[Game]</span></p>
                        <p class="text-lg mb-1"><strong>Format:</strong> <span id="tournament-detail-format">[Format]</span></p>
                        <p class="text-lg mb-4"><strong>Status:</strong> <span id="tournament-detail-status" class="font-medium">[Status]</span></p>
    
                        <div class="mt-6 mb-3">
                            <h3 class="text-xl font-semibold text-indigo-600 inline-block mr-2">Participants</h3>
                             

                        </div>
                       <div id="tournament-detail-participants" class="space-y-2">
                           <p class="text-gray-500 italic">Loading participants...</p>
                       </div>
    
                       <h2 class="text-2xl font-semibold mt-8 mb-5 text-indigo-700">Bracket / Matches / Standings</h2>
                        <div id="tournament-detail-visualization" class="border-2 border-dashed border-gray-300 p-12 text-center text-gray-500 rounded-lg min-h-[250px]">
                            Tournament Visualization Area
                            <br>(Requires JavaScript library or custom rendering based on format)
                            <br> <span class="text-xs italic">(Implementation Pending)</span>
                        </div>
                        <div class="admin-only mt-6">
                            <button class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-5 rounded-lg shadow hover:shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                                Report Match Result </button>
                             
                        </div>
                    </div>
                 </div>
            </section>
            <section id="register-section" class="page-section hidden">
                <h1 class="text-4xl font-bold ... text-center">Player Registration</h1>
                <div class="bg-white p-10 rounded-xl shadow-xl max-w-lg mx-auto">
                    <form id="register-form">
                        <div class="mb-4">
                            <label for="register-email" class="block ...">Email:</label>
                            <input type="email" id="register-email" name="email" class="shadow appearance-none border ..." required>
                        </div>
                        <div class="mb-6">
                            <label for="register-password" class="block ...">Password:</label>
                            <input type="password" id="register-password" name="password" class="shadow appearance-none border ..." required>
                        </div>
                        <div class="mb-4">
                            <label for="register-player-name" class="block ...">Player Name:</label>
                            <input type="text" id="register-player-name" name="player-name" class="shadow appearance-none border ..." required>
                        </div>
                        <div id="register-error" class="text-red-500 text-sm mb-4 hidden"></div>
                        <button type="submit" class="w-full bg-green-600 hover:bg-green-700 ...">Register</button>
                    </form>
                    <p class="text-center mt-4">Already have an account? <a href="#player-login-section" class="text-blue-600 hover:underline nav-link" data-target="player-login-section">Login here</a></p>
                </div>
           </section>
           
           <section id="player-login-section" class="page-section hidden">
                <h1 class="text-4xl font-bold ... text-center">Player Login</h1>
                <div class="bg-white p-10 rounded-xl shadow-xl max-w-lg mx-auto">
                    <form id="player-login-form">
                        <div class="mb-4">
                            <label for="player-login-email" class="block ...">Email:</label>
                            <input type="email" id="player-login-email" name="email" class="shadow appearance-none border ..." required>
                        </div>
                        <div class="mb-6">
                            <label for="player-login-password" class="block ...">Password:</label>
                            <input type="password" id="player-login-password" name="password" class="shadow appearance-none border ..." required>
                        </div>
                        <div id="player-login-error" class="text-red-500 text-sm mb-4 hidden"></div>
                        <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 ...">Login</button>
                        <button type="button" id="google-signin-button" class="w-full bg-red-500 hover:bg-red-600 text-white ... mt-4">Sign In with Google</button>
                    </form>
                     <p class="text-center mt-4">Need an account? <a href="#register-section" class="text-blue-600 hover:underline nav-link" data-target="register-section">Register here</a></p>
                </div>
           </section>
        <section id="login-section" class="page-section hidden">
             <h1 class="text-4xl font-bold text-gray-900 border-b-2 border-blue-200 pb-3 mb-6 text-center">Admin Login</h1>
             <div class="bg-white p-10 rounded-xl shadow-xl max-w-lg mx-auto">
                 <form id="login-form">
                     <div class="mb-6">
                         <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password:</label>
                         <input type="password" id="password" name="password" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" required>
                     </div>
                     <div id="login-error" class="text-red-500 text-sm mb-4 hidden">Incorrect password.</div>
                     <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75"> Login </button>
                 </form>
             </div>
        </section>

        </div>

    <div id="player-info-modal" class="modal-overlay">
        <div class="modal-content">
             <button id="close-player-modal-btn" class="modal-close-button">&times;</button>
             <div class="flex items-start space-x-6 mb-4">
                 <img id="modal-player-icon" src="https://placehold.co/80x80/cccccc/ffffff?text=?" alt="Player Icon" class="w-20 h-20 rounded-full flex-shrink-0 object-cover border-2 border-indigo-200">
                 <div class="flex-grow">
                     <h2 id="modal-player-name" class="text-3xl font-semibold mb-1 editable-field">Player Name</h2>
                     <input type="text" id="modal-edit-player-name-input" class="editing-field shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 text-xl font-semibold mb-1" placeholder="Player Name">
                     <div class="text-sm text-gray-600 mt-1" id="modal-player-overall-stats">
                         Loading stats...
                     </div>
                      <div class="editing-field mt-2">
                          <label for="modal-edit-player-icon-input" class="block text-gray-700 text-sm font-bold mb-1">Icon URL:</label>
                          <input type="url" id="modal-edit-player-icon-input" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="https://example.com/icon.png">
                      </div>
                 </div>
                 <div class="admin-only">
                    <div class="view-mode-controls">
                        <button id="edit-player-modal-btn" class="bg-yellow-100 hover:bg-yellow-200 text-yellow-800 font-bold py-2 px-4 rounded-lg text-sm">Edit</button>
                    </div>
                    <div class="edit-mode-controls space-x-2">
                        <button id="save-player-changes-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg text-sm">Save</button>
                        <button id="cancel-player-edit-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg text-sm">Cancel</button>
                        <button id="delete-player-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm ml-4">Delete Player</button>
                    </div>
                </div>
             </div>
             <div class="mt-4 border-t pt-4">
                 <h3 class="text-xl font-semibold mb-3 text-indigo-600">Game Ratings (Elo)</h3>
                 <div id="modal-player-game-stats" class="text-sm text-gray-700 grid grid-cols-2 gap-x-4 gap-y-1">
                     <p class="text-gray-500 col-span-2">Loading ratings...</p>
                 </div>
             </div>
             <div class="mt-4 border-t pt-4">
                 <h3 class="text-xl font-semibold mb-3 text-indigo-600">Recent Activity</h3>
                 <ul id="modal-player-recent-activity" class="list-disc list-inside space-y-1 text-sm text-gray-700">
                     <li class="text-gray-500">Loading activity...</li>
                 </ul>
             </div>
         </div>
    </div>
    <div id="record-game-modal" class="modal-overlay"> </div>
    <div id="add-player-modal" class="modal-overlay"> </div>
    <div id="create-tournament-modal" class="modal-overlay"> </div>
    <div id="add-game-modal" class="modal-overlay"> </div>
    <div id="edit-tournament-modal" class="modal-overlay">
    </div> <div id="add-participants-modal" class="modal-overlay"></div>
    <div id="add-course-modal" class="modal-overlay">
    
        <section id="live-game-section" class="page-section hidden space-y-8">
            <h1 class="text-4xl font-bold text-gray-900 border-b-2 border-blue-200 pb-3 mb-6">Play Live Game</h1>
    
            <div class="bg-white p-8 rounded-xl shadow-lg">
                <div class="mb-6">
                    <label for="live-game-select" class="block text-gray-700 text-sm font-bold mb-2">Select Game:</label>
                    <select id="live-game-select" name="live-game-select" class="shadow border rounded-lg w-full md:w-1/2 py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="">-- Select a Game --</option>
                        <option value="golf">Golf</option>
                        <option value="pool">Pool</option>
                        <option value="chess">Chess</option>
                        <option value="board_game">Board Game (Generic)</option>
                         </select>
                </div>
    
                <div id="live-game-tools-container" class="space-y-6">
                    <p class="text-gray-500 italic">Select a game to see available tools.</p>
                </div>
    
                 <div id="live-game-submit-area" class="mt-8 text-center border-t pt-6" style="display: none;">
                     <button id="submit-live-game-score-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow hover:shadow-md">
                        Finish Game & Submit Score
                    </button>
                </div>
            </div>
        </section>
    
    <section id="submit-past-game-section" class="page-section hidden space-y-8">
        <h1 class="text-4xl font-bold text-gray-900 border-b-2 border-blue-200 pb-3 mb-6">Submit Past Game</h1>
        <div class="bg-white p-8 rounded-xl shadow-lg max-w-2xl mx-auto">
            <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Enter Final Score Details</h2>
            <form id="submit-past-game-form">
                <div class="mb-4">
                    <label for="past-game-type" class="block text-gray-700 text-sm font-bold mb-2">Game Type:</label>
                    <select id="past-game-type" name="game-type" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                        <option value="">Select Game Type</option>
                        </select>
                </div>
                <div class="mb-4">
                    <label for="past-winner" class="block text-gray-700 text-sm font-bold mb-2">Winner:</label>
                    <select id="past-winner" name="winner" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                        <option value="">Select Winner</option>
                        </select>
                </div>
                <div class="mb-4">
                    <label for="past-loser" class="block text-gray-700 text-sm font-bold mb-2">Loser:</label>
                    <select id="past-loser" name="loser" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                        <option value="">Select Loser</option>
                        </select>
                </div>
                 <div class="mb-4">
                     <label class="inline-flex items-center">
                        <input type="checkbox" id="past-is-draw" name="is_draw" class="form-checkbox h-5 w-5 text-blue-600">
                        <span class="ml-2 text-gray-700">Was it a Draw?</span>
                     </label>
                 </div>
                <div class="mb-4">
                    <label for="past-score" class="block text-gray-700 text-sm font-bold mb-2">Score (Optional):</label>
                    <input type="text" id="past-score" name="score" placeholder="e.g. 8-3, 21-15" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700">
                </div>
                <div class="mb-4">
                    <label for="past-date-played" class="block text-gray-700 text-sm font-bold mb-2">Date Played:</label>
                    <input type="date" id="past-date-played" name="date_played" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700" required>
                </div>
                <div class="mt-6 flex justify-end">
                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-5 rounded-lg">Submit Game Info</button>
                </div>
            </form>
        </div>
    </section>

    <section id="game-info-section" class="page-section hidden space-y-8">
        <h1 class="text-4xl font-bold text-gray-900 border-b-2 border-blue-200 pb-3 mb-6">Game Information</h1>
        <div id="game-info-content" class="bg-white p-8 rounded-xl shadow-lg max-w-2xl mx-auto">
            <p class="text-gray-500">Game details will be displayed here after submission...</p>
            </div>
         <div class="text-center mt-6">
            <button id="share-game-info-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg mr-2">Share</button>
            <a href="#home-section" class="nav-link text-indigo-600 hover:underline" data-target="home-section">Back to Dashboard</a>
        </div>
    </section>
</div>
    <footer class="fixed bottom-5 left-0 right-0 text-center text-gray-600 dark:text-gray-400 text-sm z-40"> &copy; 2025 LeaderBored. Keep it friendly!
    </footer>

    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script>


function setupLiveGameSection() {
    const gameSelect = document.getElementById('live-game-select');
    const toolsContainer = document.getElementById('live-game-tools-container');
    const submitArea = document.getElementById('live-game-submit-area');

    // Populate game select from config (optional, if not hardcoded in HTML)
    // populateSelectWithOptions(gameSelect, gameTypesConfig, '-- Select a Game --');

    gameSelect?.addEventListener('change', () => {
        const selectedGame = gameSelect.value;
        loadLiveGameTools(selectedGame, toolsContainer, submitArea);
    });

    // Listener for the submit button within the live game section
    document.getElementById('submit-live-game-score-btn')?.addEventListener('click', () => {
        const selectedGame = document.getElementById('live-game-select')?.value;
        navigateToSubmitScore(selectedGame); // Navigate to the submit score page
    });
}

function loadLiveGameTools(gameKey, container, submitArea) {
    if (!container || !submitArea) return;

    container.innerHTML = ''; // Clear previous tools
    submitArea.style.display = 'none'; // Hide submit button initially

    if (!gameKey) {
        container.innerHTML = '<p class="text-gray-500 italic">Select a game to see available tools.</p>';
        return;
    }

    console.log(`Loading tools for: ${gameKey}`);
    let toolsHtml = '';

    switch (gameKey) {
        case 'golf':
            // Placeholder - In reality, you'd generate or fetch complex scorecard UI
            toolsHtml = ``; // Replace with actual HTML template string
             toolsHtml = `
                <div id="golf-tools">
    <h3 class="text-xl font-semibold mb-4 text-indigo-600">Golf Scorecard</h3>
    <div class="mb-4 p-4 border rounded-lg bg-gray-50">
        <p class="text-center text-gray-600 italic">Golf scorecard spreadsheet/table functionality requires more advanced implementation (e.g., using a JS grid library or significant custom code).</p>
        <p class="text-center mt-2 text-sm">Placeholder for round stats table.</p>
        <table class="w-full mt-4 text-sm border-collapse border border-gray-300">
            <thead>
                <tr class="bg-gray-100">
                    <th class="border border-gray-300 p-2">Hole</th>
                    <th class="border border-gray-300 p-2">Par</th>
                    <th class="border border-gray-300 p-2">Score</th>
                    <th class="border border-gray-300 p-2">Puts</th>
                    </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="border border-gray-300 p-2 text-center">1</td>
                    <td class="border border-gray-300 p-2 text-center">4</td>
                    <td class="border border-gray-300 p-2"><input type="number" class="w-16 p-1 border rounded text-center" /></td>
                    <td class="border border-gray-300 p-2"><input type="number" class="w-16 p-1 border rounded text-center" /></td>
                </tr>
                <tr><td colspan="4" class="text-center p-2 italic">... more holes ...</td></tr>
            </tbody>
        </table>
    </div>
    <div class="text-center">
        <button class="text-blue-600 hover:underline" onclick="alert('Hole detail view not implemented')">View Fullscreen Hole Detail (Example)</button>
    </div>
</div>`;
            break;
        case 'pool':
            toolsHtml = ``; // Replace with actual HTML template string
            toolsHtml = `
                <div id="pool-tools" class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <div class="border p-4 rounded-lg">
        <h3 class="text-lg font-semibold mb-3">Pool Score (Rounds)</h3>
        <div id="pool-scoring-area" class="space-y-3">
            <p class="text-sm mb-2">Game: <span id="pool-game-status">Best 2 out of 3</span></p>
            <div class="flex items-center justify-between">
                <label for="score-pool-p1">Player 1:</label>
                <input type="number" id="score-pool-p1" value="0" min="0" class="border rounded px-2 py-1 score-input w-20">
            </div>
            <div class="flex items-center justify-between">
                <label for="score-pool-p2">Player 2:</label>
                <input type="number" id="score-pool-p2" value="0" min="0" class="border rounded px-2 py-1 score-input w-20">
            </div>
        </div>
         <button id="pool-next-round-btn" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm w-full">Record Round Winner</button>
         </div>

    <div class="border p-4 rounded-lg">
        <h3 class="text-lg font-semibold mb-3">Timer</h3>
        <div id="pool-timer-display" class="timer-display text-center">00:00</div>
         <div class="mb-3 flex justify-center space-x-4">
             <label class="inline-flex items-center">
                 <input type="radio" name="pool-timer-mode" value="up" checked class="form-radio"> <span class="ml-1 text-sm">Count Up</span>
             </label>
             <label class="inline-flex items-center">
                 <input type="radio" name="pool-timer-mode" value="down" class="form-radio"> <span class="ml-1 text-sm">Count Down</span>
             </label>
         </div>
         <div id="pool-timer-settings-down" class="mb-3 hidden text-center">
              <label for="pool-timer-start-minutes" class="text-sm mr-1">Mins:</label>
              <input type="number" id="pool-timer-start-minutes" value="5" min="1" class="border rounded px-2 py-1 w-16 text-sm">
         </div>
        <div class="flex justify-center space-x-2">
            <button id="pool-timer-start" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm">Start</button>
            <button id="pool-timer-pause" class="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded text-sm">Pause</button>
            <button id="pool-timer-reset" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Reset</button>
        </div>
    </div>

     <div class="border p-4 rounded-lg text-center md:col-span-2">
        <h3 class="text-lg font-semibold mb-3">Coin Flip (for Break/Turn)</h3>
        <div id="pool-coin-result" class="text-4xl font-bold my-4">ü™ô</div>
        <button id="pool-flip-coin-btn" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded text-sm">Flip Coin</button>
    </div>
</div>`;
            break;
        case 'chess':
             toolsHtml = ``; // Replace with actual HTML template string
             toolsHtml = `
                <div id="chess-tools">
    <h3 class="text-xl font-semibold mb-4 text-indigo-600">Chess Timers</h3>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="border p-4 rounded-lg text-center">
            <h4 class="text-lg font-medium mb-2">Player 1 Clock</h4>
            <div id="chess-timer-p1" class="timer-display">10:00</div>
            <button id="chess-switch-p1" class="bg-gray-500 hover:bg-gray-700 text-white px-4 py-2 rounded text-sm w-full mt-2">Switch to Player 2</button>
        </div>
         <div class="border p-4 rounded-lg text-center">
            <h4 class="text-lg font-medium mb-2">Player 2 Clock</h4>
            <div id="chess-timer-p2" class="timer-display">10:00</div>
            <button id="chess-switch-p2" class="bg-gray-500 hover:bg-gray-700 text-white px-4 py-2 rounded text-sm w-full mt-2" disabled>Switch to Player 1</button>
        </div>
        <div class="md:col-span-2 border p-4 rounded-lg">
            <h4 class="text-lg font-medium mb-3 text-center">Game Controls</h4>
            <div class="flex justify-center space-x-2">
                <button id="chess-timer-start" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm">Start Game</button>
                <button id="chess-timer-pause" class="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded text-sm">Pause</button>
                <button id="chess-timer-reset" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Reset Clocks</button>
            </div>
             <div class="mt-3 text-center">
                 <label for="chess-time-control" class="text-sm mr-1">Time (mins):</label>
                 <input type="number" id="chess-time-control" value="10" min="1" class="border rounded px-2 py-1 w-16 text-sm">
            </div>
        </div>
    </div>
</div>`;
            break;
        case 'board_game': // Generic board game
            toolsHtml = ``; // Replace with actual HTML template string
            toolsHtml = `
                 <div id="board_game-tools" class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <div class="border p-4 rounded-lg text-center">
        <h3 class="text-lg font-semibold mb-3">Dice Roller</h3>
        <div id="board-dice-result" class="dice-result">üé≤</div>
        <button id="board-roll-dice-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded text-sm">Roll Dice</button>
    </div>

    <div class="border p-4 rounded-lg text-center">
        <h3 class="text-lg font-semibold mb-3">Coin Flip</h3>
        <div id="board-coin-result" class="text-4xl font-bold my-4">ü™ô</div>
        <button id="board-flip-coin-btn" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded text-sm">Flip Coin</button>
    </div>

     <div class="border p-4 rounded-lg md:col-span-2">
        <h3 class="text-lg font-semibold mb-3">Simple Timer</h3>
        <div id="board-timer-display" class="timer-display text-center">00:00</div>
         <div class="mb-3 flex justify-center space-x-4">
             <label class="inline-flex items-center">
                 <input type="radio" name="board-timer-mode" value="up" checked class="form-radio"> <span class="ml-1 text-sm">Count Up</span>
             </label>
             <label class="inline-flex items-center">
                 <input type="radio" name="board-timer-mode" value="down" class="form-radio"> <span class="ml-1 text-sm">Count Down</span>
             </label>
         </div>
         <div id="board-timer-settings-down" class="mb-3 hidden text-center">
              <label for="board-timer-start-minutes" class="text-sm mr-1">Mins:</label>
              <input type="number" id="board-timer-start-minutes" value="15" min="1" class="border rounded px-2 py-1 w-16 text-sm">
         </div>
        <div class="flex justify-center space-x-2">
            <button id="board-timer-start" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm">Start</button>
            <button id="board-timer-pause" class="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded text-sm">Pause</button>
            <button id="board-timer-reset" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Reset</button>
        </div>
    </div>
</div>`;
            break;
        default:
            toolsHtml = '<p class="text-gray-500 italic">No specific tools configured for this game.</p>';
    }

    container.innerHTML = toolsHtml;
    submitArea.style.display = 'block'; // Show the submit button area

    // Re-attach listeners for dynamically added elements
    attachDynamicToolListeners(gameKey);
}

function attachDynamicToolListeners(gameKey) {
    // Remove previous listeners if necessary (more complex, omitted for brevity)
    console.log(`Attaching listeners for ${gameKey} tools`);

    switch (gameKey) {
        case 'pool':
            document.getElementById('pool-timer-start')?.addEventListener('click', () => startPoolTimer()); // Use specific timer functions
            document.getElementById('pool-timer-pause')?.addEventListener('click', pausePoolTimer);
            document.getElementById('pool-timer-reset')?.addEventListener('click', resetPoolTimer);
            document.querySelectorAll('input[name="pool-timer-mode"]').forEach(radio => {
                 radio.addEventListener('change', (e) => {
                    document.getElementById('pool-timer-settings-down').classList.toggle('hidden', e.target.value !== 'down');
                 });
            });
            document.getElementById('pool-flip-coin-btn')?.addEventListener('click', flipPoolCoin);
            // Add pool scoring logic listener if needed
             document.getElementById('pool-next-round-btn')?.addEventListener('click', () => alert('Pool round scoring not implemented'));
            break;
        case 'chess':
            // Add chess timer logic listeners
             document.getElementById('chess-timer-start')?.addEventListener('click', () => alert('Chess timer start not implemented'));
             document.getElementById('chess-timer-pause')?.addEventListener('click', () => alert('Chess timer pause not implemented'));
             document.getElementById('chess-timer-reset')?.addEventListener('click', () => alert('Chess timer reset not implemented'));
             document.getElementById('chess-switch-p1')?.addEventListener('click', () => alert('Chess switch P1 not implemented'));
             document.getElementById('chess-switch-p2')?.addEventListener('click', () => alert('Chess switch P2 not implemented'));
            break;
        case 'board_game':
             document.getElementById('board-timer-start')?.addEventListener('click', () => startBoardTimer());
             document.getElementById('board-timer-pause')?.addEventListener('click', pauseBoardTimer);
             document.getElementById('board-timer-reset')?.addEventListener('click', resetBoardTimer);
              document.querySelectorAll('input[name="board-timer-mode"]').forEach(radio => {
                 radio.addEventListener('change', (e) => {
                    document.getElementById('board-timer-settings-down').classList.toggle('hidden', e.target.value !== 'down');
                 });
             });
             document.getElementById('board-roll-dice-btn')?.addEventListener('click', rollBoardDice);
             document.getElementById('board-flip-coin-btn')?.addEventListener('click', flipBoardCoin);
            break;
         case 'golf':
            // Listeners for golf scorecard inputs if needed
            break;
    }
     // Generic Timer/Dice logic from original file (if needed for games without specific versions)
    // E.g., document.getElementById('timer-start')?.addEventListener('click', startTimer);
     // E.g., document.getElementById('roll-dice-btn')?.addEventListener('click', rollDice);
}

// --- Navigation to Submit Score ---
// This function prepares and navigates to the existing 'submit-past-game-section'
// which will now serve as the unified "Submit Score" screen.
function navigateToSubmitScore(gameKey = null, /* add other params like scores if needed */) {
    console.log(`Navigating to Submit Score screen. Game: ${gameKey || 'Not specified'}`);

    const submitSection = document.getElementById('submit-past-game-section');
    if (!submitSection) {
        console.error("Submit Past Game section not found!");
        alert("Error: Cannot navigate to score submission page.");
        return;
    }

    // Get the form elements within the submit section
    const form = submitSection.querySelector('#submit-past-game-form');
    const gameTypeSelect = form?.querySelector('#past-game-type');
    const winnerSelect = form?.querySelector('#past-winner'); // Or player1 for draw
    const loserSelect = form?.querySelector('#past-loser');   // Or player2 for draw
    const scoreInput = form?.querySelector('#past-score');
    const dateInput = form?.querySelector('#past-date-played');
    const drawCheckbox = form?.querySelector('#past-is-draw');

    // --- Prepare the Form ---
    if (form) {
        form.reset(); // Clear previous entries

        // Set the game type dropdown if a gameKey was passed from the live session
        if (gameKey && gameTypeSelect) {
            if (gameTypesConfig[gameKey]) { // Check if key is valid
                 gameTypeSelect.value = gameKey;
                 // Optionally disable it if coming from a live game?
                 // gameTypeSelect.disabled = true;
            } else {
                 console.warn(`Invalid gameKey '${gameKey}' passed to navigateToSubmitScore.`);
            }
        } else if (gameTypeSelect) {
            // If navigating from "Enter Previous Score", ensure game type is enabled and empty
            gameTypeSelect.disabled = false;
            gameTypeSelect.value = '';
        }

         // Pre-fill date with today (optional)
         if (dateInput) {
             dateInput.value = new Date().toISOString().split('T')[0];
         }

        // TODO: Pre-fill players/score if data is passed from live game tools
        // Example:
        // if (winnerId) winnerSelect.value = winnerId;
        // if (loserId) loserSelect.value = loserId;
        // if (finalScore) scoreInput.value = finalScore;
        // if (wasDraw) drawCheckbox.checked = true;
    }

    // Ensure dropdowns are populated (might already be done by showSection logic)
    setupSubmitPastGameListeners(); // Re-run setup to ensure dropdowns are fresh

    // Show the section
    showSection('submit-past-game-section');
}


// --- Add specific timer/coin/dice functions for each game type ---
// Example for Pool Timer (copy and rename from generic timer functions)
let poolTimerInterval = null, poolTimerSeconds = 0, poolTimerRunning = false, poolCountdownStartSeconds = 0;
function updatePoolTimerDisplay() { /* ... */ const display = document.getElementById('pool-timer-display'); if (!display) return; const minutes = Math.floor(poolTimerSeconds / 60); const seconds = poolTimerSeconds % 60; display.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
function startPoolTimer() { /* ... */ if (poolTimerRunning) return; poolTimerRunning = true; const mode = document.querySelector('input[name="pool-timer-mode"]:checked')?.value || 'up'; if (mode === 'down' && poolTimerSeconds <= 0) { const minutesInput = document.getElementById('pool-timer-start-minutes'); poolCountdownStartSeconds = (parseInt(minutesInput?.value, 10) || 5) * 60; poolTimerSeconds = poolCountdownStartSeconds; if(poolTimerSeconds <= 0){ alert("Set countdown time."); poolTimerRunning = false; return; } } updatePoolTimerDisplay(); poolTimerInterval = setInterval(() => { if (mode === 'up') poolTimerSeconds++; else { poolTimerSeconds--; if (poolTimerSeconds < 0) { clearInterval(poolTimerInterval); poolTimerRunning = false; poolTimerSeconds = 0; alert("Pool time's up!"); } } updatePoolTimerDisplay(); }, 1000); }
function pausePoolTimer() { /* ... */ clearInterval(poolTimerInterval); poolTimerRunning = false; }
function resetPoolTimer() { /* ... */ clearInterval(poolTimerInterval); poolTimerRunning = false; const mode = document.querySelector('input[name="pool-timer-mode"]:checked')?.value || 'up'; poolTimerSeconds = (mode === 'down' && poolCountdownStartSeconds > 0) ? poolCountdownStartSeconds : 0; updatePoolTimerDisplay(); }

// Example for Pool Coin Flip
function flipPoolCoin() { /* ... */ const resultEl = document.getElementById('pool-coin-result'); if (!resultEl) return; resultEl.textContent = Math.random() < 0.5 ? 'Heads' : 'Tails'; /* Add animation? */ }

// Example for Board Game Timer
let boardTimerInterval = null, boardTimerSeconds = 0, boardTimerRunning = false, boardCountdownStartSeconds = 0;
function updateBoardTimerDisplay() { /* ... copy logic ... */ const display = document.getElementById('board-timer-display'); if (!display) return; const minutes = Math.floor(boardTimerSeconds / 60); const seconds = boardTimerSeconds % 60; display.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
function startBoardTimer() { /* ... copy logic ... */ if (boardTimerRunning) return; boardTimerRunning = true; const mode = document.querySelector('input[name="board-timer-mode"]:checked')?.value || 'up'; if (mode === 'down' && boardTimerSeconds <= 0) { const minutesInput = document.getElementById('board-timer-start-minutes'); boardCountdownStartSeconds = (parseInt(minutesInput?.value, 10) || 15) * 60; boardTimerSeconds = boardCountdownStartSeconds; if(boardTimerSeconds <= 0){ alert("Set countdown time."); boardTimerRunning = false; return; } } updateBoardTimerDisplay(); boardTimerInterval = setInterval(() => { if (mode === 'up') boardTimerSeconds++; else { boardTimerSeconds--; if (boardTimerSeconds < 0) { clearInterval(boardTimerInterval); boardTimerRunning = false; boardTimerSeconds = 0; alert("Board game time's up!"); } } updateBoardTimerDisplay(); }, 1000); }
function pauseBoardTimer() { /* ... copy logic ... */ clearInterval(boardTimerInterval); boardTimerRunning = false; }
function resetBoardTimer() { /* ... copy logic ... */ clearInterval(boardTimerInterval); boardTimerRunning = false; const mode = document.querySelector('input[name="board-timer-mode"]:checked')?.value || 'up'; boardTimerSeconds = (mode === 'down' && boardCountdownStartSeconds > 0) ? boardCountdownStartSeconds : 0; updateBoardTimerDisplay(); }

// Example for Board Game Dice
function rollBoardDice() { /* ... */ const diceResultEl = document.getElementById('board-dice-result'); if (!diceResultEl) return; const roll = Math.floor(Math.random() * 6) + 1; const diceFaces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ']; diceResultEl.textContent = diceFaces[roll - 1]; }

// Example for Board Game Coin Flip
function flipBoardCoin() { /* ... */ const resultEl = document.getElementById('board-coin-result'); if (!resultEl) return; resultEl.textContent = Math.random() < 0.5 ? 'Heads' : 'Tails'; }

// --- Modify initializeApp or setupEventListeners to include setup ---
// Make sure to call setupLiveGameSection() within your initialization logic
// Example modification in initializeApp:
// async function initializeApp() {
//      ... other init stuff ...
//      setupEventListeners(); // General listeners
//      setupLiveGameSection(); // Setup listeners specific to the live game section controls
//      ... rest of init ...
// }

// --- Modify Nav Handlers if needed ---
// Ensure the "PLAY LIVE GAME" nav link correctly targets 'live-game-section'
// Ensure the "SUBMIT PAST GAME" nav link calls navigateToSubmitScore(null) or directly targets 'submit-past-game-section'

// Modify the nav link handler for "SUBMIT PAST GAME"
function handleNavLinkClick(event) {
     const linkElement = event.target.closest('[data-target]');
     if (linkElement) {
         event.preventDefault();
         const targetId = linkElement.getAttribute('data-target');

         if (targetId === 'submit-past-game-section') {
             // Special handling for the 'Submit Past Game' link
             navigateToSubmitScore(null); // Navigate using the function
         } else if (targetId) {
             showSection(targetId); // Normal navigation for other links
         }
     }
}

// --- Generic Modal Utilities ---
function openModal(modalElement) {
            if (!modalElement) {
                console.error("openModal: Provided modalElement is null or undefined.");
                return;
            }
            console.log(`[MODAL] Opening modal: #${modalElement.id}`);
            modalElement.classList.add('active'); // Make the modal overlay visible
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }
        // --- End Generic Modal Utilities ---
        function closeModal(modalElement) {
            if (!modalElement) {
                console.error("closeModal: Provided modalElement is null or undefined.");
                return;
            }
            console.log(`[MODAL] Closing modal: #${modalElement.id}`);
            modalElement.classList.remove('active'); // Hide the modal overlay
            document.body.style.overflow = ''; // Restore background scrolling
            // Clear the modal's content IF it's dynamically generated each time
            // Check if this modal typically has dynamic content before clearing
            const modalsToClear = ['record-game-modal', 'add-player-modal', 'create-tournament-modal', 'add-game-modal', 'edit-tournament-modal'];
            if (modalsToClear.includes(modalElement.id)) {
                 modalElement.innerHTML = ''; // Clear dynamic content
                 console.log(`[MODAL] Cleared content for #${modalElement.id}`);
            }
             // Special handling for player info modal if needed (it might just hide/show)
             if (modalElement.id === 'player-info-modal') {
                 modalElement.classList.remove('modal-editing'); // Reset edit state if applicable
                 modalElement.removeAttribute('data-current-player-id'); // Clear stored ID
             }
        }
let globalPlayerCache = {}; // Cache for player data { id: { name: '...', iconUrl: '...' } }
let playersCachePopulated = false; // Flag to track if initial population happened
        // --- Basic Page Navigation & Admin Simulation ---
        const ADMIN_PASSWORD = "admin"; // Simple password for demo
        const DEFAULT_ELO = 1200; // Default starting Elo
        const K_FACTOR = 32; // Elo K-factor (adjust sensitivity)

        // --- Game Type Configuration (Single Source of Truth) ---
        // Key: used in Firestore (elos.<key>) and element IDs (ranking-table-<key>)
        // Value: Display Name used in dropdowns and headings
        let gameTypesConfig = {
            pool: "Pool",
            puttpong: "PuttPong",
            cornhole: "Cornhole",
            pickleball: "Pickleball",
            basketball_horse: "Basketball (HORSE)",
            golf: "Golf",
            // Add other predefined games here
            // New games added by admin will be appended to this object
        };
        // Create a list of keys that use Elo for easy iteration
        let ELO_GAME_KEYS = Object.keys(gameTypesConfig);


        // --- DOM Element References ---
        let sections, navLinks, loginForm, loginError, logoutButton,
            recordGameModal, openRecordGameModalBtn, // recordGameModal is now also used for editing
            addPlayerModal, openAddPlayerModalBtn,
            createTournamentModal, openCreateTournamentModalBtn,
            addGameModal, openAddGameModalBtn,
            rankingsGameFilter, rankingTablesContainer,
            resultsTableBody,
            playersGrid,
            playerInfoModal,
            manageTournamentsListContainer, // Might be unused
            tournamentDetailSection; // NEW: Reference to the detail section

        // --- Firebase Initialization ---
        let app, db;
        try {
            // IMPORTANT: Replace with your actual Firebase configuration
            const firebaseConfig = {
              apiKey: "AIzaSyCF3az8WEAMVpAx5cbp917EUhNM5cRzvwA", // Replace
              authDomain: "leaderbored2.firebaseapp.com", // Replace
              projectId: "leaderbored2", // Replace
              storageBucket: "leaderbored2.appspot.com", // Replace
              messagingSenderId: "449176616925", // Replace
              appId: "1:449176616925:web:8149e2e8b43a9a72104034", // Replace
              measurementId: "G-8LRFJGV2XY" // Optional: Replace
            };
            if (!firebaseConfig.apiKey || !firebaseConfig.projectId) {
                console.error("Firebase config is missing critical values (apiKey or projectId).");
                alert("Firebase configuration is incomplete. Please check the script.");
            } else {
                app = firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                auth = firebase.auth();
                console.log("[INIT] Firebase Initialized Successfully with Project ID:", firebaseConfig.projectId);
            }
        } catch (error) {
            console.error("[INIT] Error initializing Firebase:", error);
            alert("Could not connect to Firebase. Please check your configuration and console.");
        }

        // --- Assign DOM Elements ---
        function assignElements() {
            sections = document.querySelectorAll('.page-section');
            navLinks = document.querySelectorAll('.nav-link');
            loginForm = document.getElementById('login-form');
            loginError = document.getElementById('login-error');
            logoutButton = document.getElementById('logout-button');
            // Modals and their trigger buttons
            recordGameModal = document.getElementById('record-game-modal'); // Used for Record AND Edit
            openRecordGameModalBtn = document.getElementById('open-record-game-modal-btn');
            addPlayerModal = document.getElementById('add-player-modal');
            openAddPlayerModalBtn = document.getElementById('open-add-player-modal-btn');
            createTournamentModal = document.getElementById('create-tournament-modal');
            openCreateTournamentModalBtn = document.getElementById('open-create-tournament-modal-btn');
            addGameModal = document.getElementById('add-game-modal');
            openAddGameModalBtn = document.getElementById('open-add-game-modal-btn');
            addParticipantsModal = document.getElementById('add-participants-modal'); // <<< ADD THIS LINE

            // Other elements
            rankingsGameFilter = document.getElementById('rankings-game-filter');
            rankingTablesContainer = document.getElementById('ranking-tables-container');
            resultsTableBody = document.getElementById('results-table-body');
            playersGrid = document.querySelector('#players-section #players-grid');
            playerInfoModal = document.getElementById('player-info-modal');
            manageTournamentsListContainer = document.getElementById('manage-tournaments-list-container'); // Might be unused
            tournamentDetailSection = document.getElementById('tournament-detail-section'); // NEW

            // Add checks
            if (!resultsTableBody) console.error("Critical Error: Results table body (#results-table-body) not found!");
            if (!playersGrid) console.error("Critical Error: Players grid container (#players-grid) not found!");
            if (!recordGameModal) console.error("Critical Error: Record/Edit Game Modal container (#record-game-modal) not found!");
            if (!tournamentDetailSection) console.error("Critical Error: Tournament Detail Section (#tournament-detail-section) not found!"); // NEW check
            if (!openRecordGameModalBtn) console.warn("Record Game button not found.");
            if (!openAddPlayerModalBtn) console.warn("Add Player button not found.");
            if (!openCreateTournamentModalBtn) console.warn("Create Tournament button not found.");
            if (!openAddGameModalBtn) console.warn("Add Game button not found.");
        }


        // --- Utility Functions ---
        
        
       // --- Utility Functions ---
// NEW: Fetches all players and populates the global cache
async function fetchAllPlayersForCache() {
    if (playersCachePopulated) {
        console.log("[CACHE] Global player cache already populated.");
        return true; // Already done
    }
    console.log("[CACHE] Populating global player cache...");
    const players = await getAllPlayers('name'); // Use the existing function
    if (players && players.length > 0) {
        globalPlayerCache = {}; // Reset cache
        players.forEach(player => {
            globalPlayerCache[player.id] = player; // Store the whole player object
        });
        playersCachePopulated = true;
        console.log(`[CACHE] Global player cache populated with ${Object.keys(globalPlayerCache).length} players.`);
        return true;
    } else {
        console.error("[CACHE] Failed to fetch players for global cache.");
        playersCachePopulated = false; // Mark as not populated on failure
        return false;
    }
}
// NEW: Fetches all players from Firestore
async function getAllPlayers(orderBy = 'name') {
    if (!db) {
        console.error("getAllPlayers: Firestore DB not initialized.");
        return []; // Return empty array if DB not ready
    }
    console.log(`[DATA] Fetching all players, ordered by ${orderBy}...`);
    try {
        const snapshot = await db.collection('players').orderBy(orderBy).get();
        const players = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        console.log(`[DATA] Fetched ${players.length} players.`);
        return players;
    } catch (error) {
        console.error("Error fetching players:", error);
        alert(`Error fetching player list: ${error.message}`);
        return []; // Return empty array on error
    }
}

// NEW: Populates a single select element with player options
function populatePlayerDropdown(selectElement, playersArray, prompt = 'Select Player', selectedValue = null) {
    if (!selectElement) {
        console.warn("populatePlayerDropdown: Provided selectElement is null or undefined.");
        return;
    }
    selectElement.innerHTML = `<option value="">${prompt}</option>`; // Clear existing options and add prompt
    playersArray.forEach(player => {
        const option = new Option(player.name || 'Unnamed Player', player.id);
        if (player.id === selectedValue) {
            option.selected = true; // Select the option if it matches the provided value
        }
        selectElement.add(option);
    });
    console.log(`[UI] Populated dropdown ${selectElement.id || '(no id)'} with ${playersArray.length} players.`);
}


        
        
        
        // Populates a select dropdown from an object { key: value, ... }
        function populateSelectWithOptions(selectElement, optionsObject, prompt = 'Select...') {
             if (!selectElement) { console.warn("populateSelectWithOptions: Provided selectElement is null or undefined."); return; }
             const currentValue = selectElement.value; // Preserve current selection if possible
             selectElement.innerHTML = `<option value="">${prompt}</option>`;
             for (const key in optionsObject) {
                 if (Object.hasOwnProperty.call(optionsObject, key)) {
                     const value = optionsObject[key];
                     const optionElement = document.createElement('option');
                     optionElement.value = key; // Use the key as the value
                     optionElement.textContent = value; // Use the value as the display text
                     if (key === currentValue) {
                         optionElement.selected = true;
                     }
                     selectElement.appendChild(optionElement);
                 }
             }
         }

        // --- Dynamic UI Updates ---
        // Updates dropdowns that list game types
        function updateGameTypeDropdowns() {
            console.log("[UI Update] Updating game type dropdowns...");
            const recordGameSelect = document.getElementById('game-type-select-modal'); // In Record Game Modal
            const editGameSelect = document.getElementById('edit-game-type-select-modal'); // In Edit Game Modal
            const rankingsFilterSelect = document.getElementById('rankings-game-filter'); // On Rankings Page
            const tournamentGameSelect = document.getElementById('tournament-game-type-select'); // In Create Tournament Modal

            // Add 'overall' option specifically to rankings filter if needed
            const rankingsOptions = { overall: "Overall (1v1/2v2)", ...gameTypesConfig };

            if (recordGameSelect) populateSelectWithOptions(recordGameSelect, gameTypesConfig, 'Select Game Type');
            if (editGameSelect) populateSelectWithOptions(editGameSelect, gameTypesConfig, 'Select Game Type'); // Update edit modal too
            if (rankingsFilterSelect) populateSelectWithOptions(rankingsFilterSelect, rankingsOptions); // Use combined options
            if (tournamentGameSelect) populateSelectWithOptions(tournamentGameSelect, gameTypesConfig, 'Select Type'); // Populate in create tournament modal
        }
// --- Player Authentication Functions ---
let currentPlayer = null; // Variable to store logged-in player data

async function handlePlayerRegister(event) {
    event.preventDefault();
    const form = event.target;
    const email = form.email.value;
    const password = form.password.value;
    const playerName = form['player-name'].value.trim(); // Get player name
    const errorDiv = document.getElementById('register-error');
    errorDiv.textContent = '';
    errorDiv.classList.add('hidden');

    if (!playerName) {
        errorDiv.textContent = "Player Name is required.";
        errorDiv.classList.remove('hidden');
        return;
    }

    try {
        console.log("Attempting registration for:", email);
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        const user = userCredential.user;
        console.log("Registration successful, User:", user);

        // --- Link Auth user to a new Firestore Player profile ---
        await createPlayerProfile(user.uid, email, playerName);

        alert(`Registration successful for ${playerName}! You are now logged in.`);
        // onAuthStateChanged will handle UI updates and navigation
        form.reset(); // Clear the form

    } catch (error) {
        console.error("Registration Error:", error);
        errorDiv.textContent = `Registration failed: ${error.message}`;
        errorDiv.classList.remove('hidden');
    }
}

// --- Add Course Modal Functions ---
function openAddCourseModal() {
    // Get the specific modal container element
    const modalElement = document.getElementById('add-course-modal');
    if (!modalElement) {
        console.error("Add Course modal element (#add-course-modal) not found.");
        alert("Error: Cannot open Add Course form.");
        return;
    }
    // Check for Firestore connection (important for saving)
    if (!db) {
        console.error("Add Course modal: DB not ready.");
        alert("Error: Cannot open Add Course form. Database connection failed.");
        return;
    }

    // 1. Define and Inject the specific HTML content for this modal
    const modalContentHTML = `
        <div class="modal-content">
            <button id="close-add-course-modal-btn" class="modal-close-button">&times;</button>
            <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Add New Golf Course</h2>
            <form id="add-course-form">
                <div class="mb-4">
                    <label for="course-name" class="block text-gray-700 text-sm font-bold mb-2">Course Name:</label>
                    <input type="text" id="course-name" name="course-name" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" required>
                </div>
                <div class="mb-4">
                    <label for="course-location" class="block text-gray-700 text-sm font-bold mb-2">Location (Optional):</label>
                    <input type="text" id="course-location" name="course-location" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="e.g., City, State">
                </div>
                <div class="mb-5">
                    <label for="course-par" class="block text-gray-700 text-sm font-bold mb-2">Total Par (18 Holes):</label>
                    <input type="number" id="course-par" name="course-par" min="50" max="80" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" required placeholder="e.g., 72">
                     <p class="text-xs text-gray-500 mt-1">Enter the standard 18-hole par for the course.</p>
                </div>
                <div class="mt-6 flex justify-end space-x-3">
                    <button type="button" id="cancel-add-course-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-5 rounded-lg">Add Course</button>
                </div>
            </form>
        </div>`;
    modalElement.innerHTML = modalContentHTML;

    // 2. Get references to elements *inside* the newly added modal content
    const closeButton = modalElement.querySelector('#close-add-course-modal-btn');
    const cancelButton = modalElement.querySelector('#cancel-add-course-modal-btn');
    const modalForm = modalElement.querySelector('#add-course-form');

    // 3. Add event listeners for the modal's internal controls
    if (closeButton) closeButton.addEventListener('click', closeAddCourseModal);
    if (cancelButton) cancelButton.addEventListener('click', closeAddCourseModal);
    if (modalForm) modalForm.addEventListener('submit', handleAddCourseSubmit); // Make sure handleAddCourseSubmit exists

    // 4. Call the generic openModal function
    openModal(modalElement);
}
// --- End Add Course Modal Functions ---



function closeAddCourseModal() {
    const modalElement = document.getElementById('add-course-modal');
    // Call the generic closeModal function, which handles hiding,
    // restoring scroll, and clearing content for this modal ID.
    closeModal(modalElement);
}

// Handles submission of the Add Course modal form
async function handleAddCourseSubmit(event) {
    event.preventDefault(); // Prevent default form submission
    const form = event.target; // Get the form element
    if (!db) { alert("Database connection error. Cannot add course."); return; }

    // --- Basic Form Validation ---
    let isValid = true;
    form.querySelectorAll('input[required]').forEach(field => {
        field.classList.remove('border-red-500');
        if (!field.value.trim()) { isValid = false; field.classList.add('border-red-500'); }
    });
    const courseParInput = form.querySelector('#course-par');
    const coursePar = parseInt(courseParInput?.value, 10);
    if (courseParInput && (isNaN(coursePar) || coursePar < 50 || coursePar > 80)) { // Basic par validation
        courseParInput.classList.add('border-red-500');
        isValid = false;
        alert("Please enter a valid Total Par (usually between 50 and 80).");
    }
    if (!isValid) { alert("Please fill out all required fields correctly."); return; }
    // --- End Validation ---

    const formData = new FormData(form);
    const courseName = formData.get('course-name')?.trim();
    const courseLocation = formData.get('course-location')?.trim() || null; // Store null if empty

    if (!courseName) { console.error("[ADD COURSE] Course name is empty after trim."); return; }
    console.log(`[ADD COURSE] Attempting to add course: ${courseName}`);

    try {
        const courseData = {
            name: courseName,
            location: courseLocation,
            total_par: coursePar, // Already parsed and validated
            date_created: firebase.firestore.FieldValue.serverTimestamp()
            // Add other fields like slope, rating here if you added them to the form
        };

        // Add the new course document to the 'golf_courses' collection
        const docRef = await db.collection('golf_courses').add(courseData);
        console.log(`[FIRESTORE] Course "${courseName}" added successfully with ID: ${docRef.id}`);
        alert(`Course "${courseName}" added successfully!`);
        closeAddCourseModal();

        // Refresh the courses list if the golf details view is currently visible
        const golfDetailsView = document.getElementById('golf-details-view');
        if (golfDetailsView && !golfDetailsView.classList.contains('hidden')) {
            await populateGolfCourses();
        }
        // Also refresh the course dropdown in the Record Game modal if it exists dynamically
        // (More complex, might require re-opening or specific update logic)


    } catch (error) {
        console.error("Error adding course:", error);
        alert(`Failed to add course: ${error.message}`);
    }
}


function handleNavLinkClick(event) {
    // Ensure it's a valid click event on an element
    if (!event || !event.target) return;

    // Find the closest ancestor element that has the 'data-target' attribute
    // This handles cases where the click might be on an icon inside the link
    const linkElement = event.target.closest('[data-target]');

    if (linkElement) {
        // Prevent default link behavior (like jumping to #hash)
        event.preventDefault();

        const targetId = linkElement.getAttribute('data-target');
        if (targetId) {
            console.log(`[NAV Link Click] Target section: ${targetId}`);
            // Call showSection to display the target section
            showSection(targetId);
        } else {
            console.warn("[NAV Link Click] Clicked link has no data-target attribute:", linkElement);
        }
    }
    // If the clicked element or its ancestors don't have 'data-target', do nothing special.
}

async function handlePlayerLogin(event) {
    event.preventDefault();
    const form = event.target;
    const email = form.email.value;
    const password = form.password.value;
    const errorDiv = document.getElementById('player-login-error');
    errorDiv.textContent = '';
    errorDiv.classList.add('hidden');

    try {
        console.log("Attempting login for:", email);
        await auth.signInWithEmailAndPassword(email, password);
        console.log("Player login successful");
         alert("Login successful!");
         // onAuthStateChanged will handle UI updates and navigation
         form.reset();
    } catch (error) {
        console.error("Player Login Error:", error);
        errorDiv.textContent = `Login failed: ${error.message}`;
        errorDiv.classList.remove('hidden');
    }
}

async function handleGoogleSignIn() {
    const provider = new firebase.auth.GoogleAuthProvider();
    try {
        console.log("Attempting Google Sign-In...");
        const result = await auth.signInWithPopup(provider);
        const user = result.user;
        console.log("Google Sign-In successful, User:", user);

        // Check if a player profile already exists for this Auth UID
        const playerProfile = await getPlayerProfileByAuthId(user.uid);

        if (!playerProfile) {
            // If no profile exists, create one using Google profile info
            console.log("No existing profile found, creating one...");
            await createPlayerProfile(user.uid, user.email, user.displayName, user.photoURL);
             alert(`Welcome ${user.displayName}! Profile created and logged in.`);
        } else {
            console.log("Existing profile found:", playerProfile);
            alert(`Welcome back ${playerProfile.name}!`);
        }
         // onAuthStateChanged handles UI updates
    } catch (error) {
         console.error("Google Sign-In Error:", error);
         alert(`Google Sign-In failed: ${error.message}`);
    }
}


function handlePlayerLogout() {
    auth.signOut().then(() => {
        console.log("Player logged out successfully.");
        alert("You have been logged out.");
        // onAuthStateChanged handles UI updates and navigation
    }).catch((error) => {
        console.error("Logout Error:", error);
         alert(`Logout failed: ${error.message}`);
    });
}

// Listen for authentication state changes
auth.onAuthStateChanged(async (user) => {
    if (user) {
        // Player is signed in.
        console.log("Auth State Changed: User is logged in", user.uid);
        document.body.classList.add('player-logged-in');
        document.body.classList.remove('admin-logged-in'); // Ensure admin is logged out visually
        sessionStorage.removeItem('isAdminLoggedIn'); // Clear admin session state if player logs in

        // Fetch associated player profile data
        currentPlayer = await getPlayerProfileByAuthId(user.uid);
        if (!currentPlayer) {
            console.warn("Logged in user has no associated player profile!", user.uid);
            // Handle this case - maybe force profile creation or show an error
            // For now, keep minimal user info
            currentPlayer = { authUid: user.uid, email: user.email, name: "Profile Setup Needed" };
        } else {
             console.log("Current player data:", currentPlayer);
             // Update any UI elements needing player name/icon immediately
             // Example: document.getElementById('profile-name-display').textContent = currentPlayer.name;
        }
        // Optionally navigate to a default logged-in section like home or profile
        if (!window.location.hash || window.location.hash === '#player-login-section' || window.location.hash === '#register-section') {
            showSection('home-section');
        }

    } else {
        // Player is signed out.
        console.log("Auth State Changed: User is logged out");
        document.body.classList.remove('player-logged-in');
        currentPlayer = null;
        // Navigate to home or login page on logout
        showSection('home-section');
    }
    // Always ensure admin UI is correct based on admin login state too
    checkLoginState();
});
        // --- Page Section Navigation ---
// --- Page Section Navigation (Refactored for Async and Cache Check) ---
async function showSection(targetId) { // Added async
             if (!sections) { console.error("Sections variable is not assigned yet in showSection"); return; }
             console.log(`[NAV] Navigating to: ${targetId}`);
            const cleanTargetId = targetId.startsWith('#') ? targetId.substring(1) : targetId;
            let sectionFound = false;

            sections.forEach(section => {
                if (section && section.id) section.classList.add('hidden');
            });

            const targetSection = document.getElementById(cleanTargetId);
            if (targetSection && targetSection.classList.contains('page-section')) {
                console.log(`[NAV] Showing section: ${targetSection.id}`);
                targetSection.classList.remove('hidden');
                sectionFound = true;

                // Populate content if DB is ready
                if (db) {
                    // --- Ensure Cache is Ready for Relevant Sections --- <<< ADDED BLOCK
                    const needsCache = ['home-section', 'results-section', 'players-section', 'rankings-section'];
                    if (needsCache.includes(cleanTargetId) && !playersCachePopulated) {
                        console.warn(`[NAV] Player cache not ready for ${cleanTargetId}, attempting population...`);
                        await fetchAllPlayersForCache(); // Attempt to populate if not done yet
                        if (!playersCachePopulated) {
                             // Handle case where cache population failed - maybe show error in section
                             console.error(`[NAV] Failed to populate cache before showing ${cleanTargetId}. Section content may be incomplete.`);
                             // Example: Display error in the target section
                             if(targetSection) targetSection.innerHTML = `<p class="text-red-500 p-4 text-center">Error: Could not load required player data.</p>`;
                        }
                    }
                    // --- End Cache Check ---

                    // Populate Section Content (Make calls async with await) <<< MODIFIED CALLS
                    // Only proceed if cache is populated (or for sections that don't need it)
                    if (playersCachePopulated || !needsCache.includes(cleanTargetId)) {
                        if (cleanTargetId === 'home-section') await populateDashboard();
                        if (cleanTargetId === 'rankings-section' && rankingTablesContainer) {
                            updateGameTypeDropdowns(); // Sync function
                            await updateRankingsVisibility(); // Async function
                        }
                        if (cleanTargetId === 'results-section' && resultsTableBody) await populateResultsTable(); // Async function
                        if (cleanTargetId === 'players-section' && playersGrid) await populatePlayersList(); // Async function (if needed)
                        if (cleanTargetId === 'tournaments-section' && document.getElementById('tournaments-list-full')) await populateTournamentsList('tournaments-list-full'); // Async function
                        // Note: Tournament details are populated when the link is clicked
                    } else if (needsCache.includes(cleanTargetId)) {
                         console.error(`[NAV] Cannot populate ${cleanTargetId} because player cache failed to load.`);
                         // Error message might already be displayed from cache check block
                    }

                } else {
                    console.warn(`[NAV] DB not ready, skipping population for section ${cleanTargetId}`);
                }

            } else {
                 console.warn(`[NAV] Section with ID "${cleanTargetId}" not found or invalid. Showing home.`);
                 const homeSection = document.getElementById('home-section');
                 if (homeSection) {
                     homeSection.classList.remove('hidden');
                     // Ensure cache check happens for fallback to home too
                     if (db) {
                          if(!playersCachePopulated) await fetchAllPlayersForCache();
                          if(playersCachePopulated) await populateDashboard(); // Async call
                          else console.error("[NAV] Cannot populate home section because player cache failed to load.");
                     }
                 } else {
                     console.error("Critical Error: Home section (#home-section) not found as fallback.");
                 }
            }

            if (sectionFound) {
                window.location.hash = cleanTargetId; // Update URL hash
                window.scrollTo(0, 0); // Scroll to top
            }
        }


        // --- Player List and Modal Functions (Firestore) ---
        async function populatePlayersList() {
             if (!playersGrid) { console.warn("Player grid container (#players-grid) not found."); return; }
             playersGrid.innerHTML = '<p class="text-gray-500 col-span-full text-center">Loading players...</p>';
             try {
                 if (!db) throw new Error("Firestore database (db) is not initialized.");
                 const snapshot = await db.collection('players').orderBy('name').get();
                 if (snapshot.empty) {
                     playersGrid.innerHTML = '<p class="text-gray-500 col-span-full text-center">No players found. Add players via Admin Login.</p>';
                     return;
                 }
                 playersGrid.innerHTML = ''; // Clear loading
                 snapshot.forEach(doc => {
                     const player = { id: doc.id, ...doc.data() };
                     const div = document.createElement('div');
                     div.className = 'player-entry bg-white p-5 rounded-lg shadow hover:shadow-md cursor-pointer flex items-center space-x-4 transition duration-200 ease-in-out';
                     div.setAttribute('data-player-id', player.id);
                     // Use ui-avatars.com for fallback icons
                     const iconUrl = player.iconUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(player.name || '?')}&background=E0E7FF&color=4F46E5&size=48`;
                     div.innerHTML = `
                         <img src="${iconUrl}" alt="Icon ${player.name || ''}" class="w-12 h-12 rounded-full flex-shrink-0 object-cover bg-gray-200" onerror="this.onerror=null; this.src='https://ui-avatars.com/api/?name=?&background=cccccc&color=ffffff&size=48';">
                         <span class="font-medium text-lg text-gray-800 truncate">${player.name || 'Unnamed Player'}</span> `;
                     playersGrid.appendChild(div);
                 });
             } catch (error) {
                 console.error("Error fetching players:", error);
                 playersGrid.innerHTML = `<p class="text-red-500 col-span-full text-center">Error loading players: ${error.message}</p>`;
             }
        }

        // --- Player List and Modal Functions (Firestore - Refactored for Generic Modal) ---
        // Existing populatePlayersList function remains the same...

        // --- Player Modal Functions (Handles data loading and conditional edit controls) ---

async function openPlayerModal(playerId) {
    // Get the specific modal container element
    const modalElement = document.getElementById('player-info-modal');
    if (!modalElement) {
         console.error("Player modal element (#player-info-modal) not found.");
         alert("Error: Cannot open player details. Modal element missing.");
         return;
    }
    // Check for DB connection
    if (!db) {
         console.error("Player modal: DB not ready.");
         alert("Error: Cannot open player details. Database not connected.");
         return;
    }

    const modalContent = modalElement.querySelector('.modal-content');
     if (!modalContent) {
        console.error("Player modal content div (.modal-content) not found.");
        alert("Error: Cannot open player details. Modal content missing.");
        return;
    }

    console.log(`[PLAYER MODAL] Opening modal for player ID: ${playerId}`);

    // --- References & Reset Content of Existing Elements ---
    // Get references to elements WITHIN the modal structure
    const nameEl = modalContent.querySelector('#modal-player-name');
    const statsEl = modalContent.querySelector('#modal-player-game-stats');
    const activityEl = modalContent.querySelector('#modal-player-recent-activity');
    const iconEl = modalContent.querySelector('#modal-player-icon');
    const nameInputEl = modalContent.querySelector('#modal-edit-player-name-input');
    const iconInputEl = modalContent.querySelector('#modal-edit-player-icon-input');
    const overallStatsEl = modalContent.querySelector('#modal-player-overall-stats');
    const playerEditControls = modalContent.querySelector('.player-edit-controls'); // Container for player's own edit buttons
    // Note: Admin controls visibility is handled by CSS (.admin-only and body.admin-logged-in)

    // Reset content to loading states *before* opening
    if (nameEl) nameEl.textContent = 'Loading...';
    if (statsEl) statsEl.innerHTML = '<p class="text-gray-500 col-span-2">Loading ratings...</p>';
    if (activityEl) activityEl.innerHTML = '<li class="text-gray-500">Loading activity...</li>';
    if (iconEl) iconEl.src = 'https://placehold.co/80x80/cccccc/ffffff?text=?'; // Placeholder icon
    if (nameInputEl) nameInputEl.value = ''; // Clear edit inputs
    if (iconInputEl) iconInputEl.value = ''; // Clear edit inputs
    if (overallStatsEl) overallStatsEl.innerHTML = 'Loading stats...';
    if (playerEditControls) playerEditControls.style.display = 'none'; // Hide player controls initially
    modalElement.classList.remove('modal-editing'); // Ensure it starts in view mode
    modalElement.removeAttribute('data-current-player-id'); // Clear any previous player ID
    // --- End Reset ---

    // 1. Call the generic openModal function to make the modal visible
    openModal(modalElement);

    // 2. Fetch and Populate the data *after* the modal is technically open
    try {
         // --- Fetch Player Data ---
         console.log(`[PLAYER MODAL] Fetching player data for ${playerId}...`);
         const playerDocRef = db.collection('players').doc(playerId);
         const docSnap = await playerDocRef.get();
         if (!docSnap.exists) { throw new Error(`Player document not found for ID: ${playerId}`); }
         const details = { id: docSnap.id, ...docSnap.data() };
         console.log(`[PLAYER MODAL] Player data fetched:`, details);
         // Store the current player ID on the modal element itself for reference
         modalElement.setAttribute('data-current-player-id', playerId);

         // --- Populate Basic Details ---
         const iconSrc = details.iconUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(details.name || '?')}&background=E0E7FF&color=4F46E5&size=80`;
         if(iconEl) { iconEl.src = iconSrc; iconEl.alt = `Icon ${details.name || ''}`; }
         if(nameEl) nameEl.textContent = details.name || 'Unnamed Player';
         if(nameInputEl) nameInputEl.value = details.name || ''; // Populate edit field too
         if(iconInputEl) iconInputEl.value = details.iconUrl || ''; // Populate edit field too

         // --- Populate Overall Stats ---
         if (overallStatsEl) {
             const wins = details.wins || 0; const losses = details.losses || 0; const draws = details.draws || 0; const played = details.games_played || 0;
             overallStatsEl.innerHTML = `Overall: <span class="font-medium text-green-600">${wins}W</span>/<span class="font-medium text-red-600">${losses}L</span>/<span class="font-medium text-gray-600">${draws}D</span> (${played} Played) | Elo: <span class="font-medium">${Math.round(details.elo_overall || DEFAULT_ELO)}</span>`;
         }

         // --- Populate game-specific stats (Elo or Handicap) ---
         if (statsEl) {
            console.log(`[PLAYER MODAL DEBUG] Populating game stats for ${details.name}`);
            statsEl.innerHTML = ''; // Clear loading message
            const elos = details.elos || {}; let statsHtml = '';
            Object.entries(gameTypesConfig).forEach(([gameKey, gameName]) => {
                let ratingDisplay = '';
                if (gameKey === 'golf') { // Handle Golf Handicap
                    const handicapValue = details.golf_handicap;
                    if (typeof handicapValue === 'number') {
                        ratingDisplay = `${handicapValue.toFixed(1)} Hcp`; // Format handicap
                    } else { ratingDisplay = 'Not Rated'; } // Fallback
                    statsHtml += `<div class="font-medium text-gray-900">${gameName}:</div><div class="text-blue-600 font-semibold">${ratingDisplay}</div>`;
                } else { // Handle other games (Elo)
                    const rating = Math.round(elos[gameKey] || DEFAULT_ELO); // Use elos map
                    ratingDisplay = `${rating} Elo`;
                    statsHtml += `<div class="font-medium text-gray-900">${gameName}:</div><div class="text-indigo-600">${ratingDisplay}</div>`;
                }
            });
            if (!statsHtml) { statsHtml = '<p class="text-gray-500 col-span-2 italic">No specific game stats found.</p>'; }
            statsEl.innerHTML = statsHtml; // Update the display
            console.log(`[PLAYER MODAL DEBUG] Updated #modal-player-game-stats.`);
         } else { console.error("[PLAYER MODAL DEBUG] #modal-player-game-stats element not found!"); }

         // --- Control Edit/Delete Visibility ---
         // This section determines if the PLAYER's edit controls should be shown
         if (playerEditControls) {
             // Show controls ONLY if the logged-in player (currentPlayer global variable)
             // matches the authUid of the profile being viewed (details.authUid)
             if (currentPlayer && details.authUid && currentPlayer.authUid === details.authUid) {
                 console.log("[PLAYER MODAL] Current user matches profile. Showing player edit controls.");
                 playerEditControls.style.display = 'block'; // Or 'inline-flex', check your CSS/HTML structure

                 // Optional: Hide delete button even for the player themselves
                 // const deleteBtn = playerEditControls.querySelector('#delete-player-btn');
                 // if (deleteBtn) deleteBtn.style.display = 'none';

             } else {
                 console.log("[PLAYER MODAL] Current user does not match profile (or not logged in/profile has no authUid). Hiding player edit controls.");
                 playerEditControls.style.display = 'none';
             }
         } else {
              console.warn("[PLAYER MODAL] '.player-edit-controls' container not found in modal HTML.");
         }
         // Note: Admin controls (.admin-only) visibility is handled separately by the 'body.admin-logged-in' CSS class.

         // --- Populate Recent Activity ---
         // Ensure the activity element reference is valid before calling
         if (activityEl) {
            // Ensure global player cache is populated before showing activity
            if (!playersCachePopulated) await fetchAllPlayersForCache();
            await populatePlayerRecentActivity(activityEl, playerId, 5); // Limit to 5 items
         } else {
             console.error("[PLAYER MODAL] Recent activity element (#modal-player-recent-activity) not found.");
         }

     } catch (error) {
          console.error("[PLAYER MODAL] Error fetching or populating data:", error);
          alert(`Error loading player details: ${error.message}`);
          // Close the modal if fetching fails critically
          closePlayerModal(); // Use the specific close function
     }
}
// --- Specific Event Handlers ---
// ... (keep handleNavLinkClick, handleLoginFormSubmit, etc.) ...

// Handles clicks on the "My Profile" link in the navigation
function handleMyProfileClick(event) {
    event.preventDefault(); // Prevent the link from changing the hash directly

    // Check if the currentPlayer object is populated (meaning a player is logged in)
    // and if it has the Firestore document ID
    if (currentPlayer && currentPlayer.id) {
        console.log(`[NAV] My Profile clicked. Opening modal for player ID: ${currentPlayer.id}`);
        // Open the player modal using the logged-in player's Firestore ID
        openPlayerModal(currentPlayer.id);
    } else if (currentPlayer && currentPlayer.authUid) {
        // Case where user is authenticated but profile data/ID might be missing
        console.warn("[NAV] My Profile clicked, but currentPlayer object missing Firestore ID.");
        alert("Your player profile information isn't fully loaded or linked yet. Please try again shortly.");
        // Optional: You could try fetching the profile again here
        // getPlayerProfileByAuthId(currentPlayer.authUid).then(profile => { ... });
    } else {
        // Case where no player is logged in
        console.log("[NAV] My Profile clicked, but no player logged in.");
        alert("You need to be logged in to view your profile.");
        // Navigate the user to the player login section
        showSection('player-login-section');
    }
}

// ... (rest of your JavaScript code) ...
// --- Make sure you also have the corresponding closePlayerModal function ---
function closePlayerModal() {
    const modalElement = document.getElementById('player-info-modal');
    if (!modalElement) {
        console.error("Player info modal element (#player-info-modal) not found when trying to close.");
        return;
    }
    // Call the generic closeModal function.
    // It handles hiding the modal and restoring scroll.
    // It also has special handling to reset the 'modal-editing' class
    // and remove the 'data-current-player-id' attribute for this specific modal ID.
    // It *does not* clear the innerHTML for this modal by default (based on definition in provided file context).
    closeModal(modalElement);
}

                 // --- Player List and Modal Functions (Firestore - Refactored for Generic Modal) ---
        function closePlayerModal() {
             // Get the specific modal container element
             const modalElement = document.getElementById('player-info-modal');
             if (!modalElement) {
                 console.error("Player info modal element (#player-info-modal) not found when trying to close.");
                 return;
             }
             // Call the generic closeModal function.
             // It handles hiding the modal and restoring scroll.
             // It also has special handling to reset the 'modal-editing' class
             // and remove the 'data-current-player-id' attribute for this specific modal ID.
             // It *does not* clear the innerHTML for this modal.
             closeModal(modalElement);
        }
        
        
        
        
        // Populate game-specific Elos
// --- Golf Handicap Calculation (Simplified: Average Differential of Last 10) ---
// --- Golf Handicap Calculation (Simplified: Average Differential of Last 10 - WITH DEBUG LOGS & Fixed Query) ---
async function updateGolfHandicap(playerId, scoresToConsider = 10) { // Default to last 10 scores
            // Check if DB connection and Player ID are available
            if (!db || !playerId) {
                console.warn("[HANDICAP CALC] Cannot update handicap: DB connection or Player ID missing.");
                return; // Exit if prerequisites are missing
            }
            console.log(`[HANDICAP DEBUG] === Starting calculation for player ${playerId} (Scores to consider: ${scoresToConsider}) ===`);
            // Create a cache object specifically for this calculation run to store fetched course pars
            const handicapCalcCache = {};

            try {
                // --- Step 1: Fetch recent golf scores for the player ---
                // Fetch the last N golf scores, ordered by date. We will filter for course_id in the loop below.
                // Firestore Index needed: games: player_id (==), game_type (==), date_played (desc)
                console.log(`[HANDICAP DEBUG] Fetching last ${scoresToConsider} golf scores for player ${playerId}...`);
                const gamesSnapshot = await db.collection('games')
                    .where('player_id', '==', playerId)
                    .where('game_type', '==', 'golf')
                    // REMOVED: .where('course_id', '!=', null) // Inequality removed to fix query error
                    .orderBy('date_played', 'desc') // Order by date is now allowed as the first orderBy
                    .limit(scoresToConsider)
                    .get();

                // Check if any golf scores were found
                if (gamesSnapshot.empty) {
                    console.log(`[HANDICAP DEBUG] No golf scores found for player ${playerId}. Exiting calculation.`);
                    return; // No scores to process
                }
                console.log(`[HANDICAP DEBUG] Found ${gamesSnapshot.size} potential scores to evaluate.`);

                // --- Step 2: Define helper to get course par (uses shared function now) ---
                // (Ensure getCourseParById function is defined elsewhere in your script)


                // --- Step 3: Calculate differentials (Score - Par) for each valid round ---
                const differentials = []; // Array to store valid differentials
                console.log(`[HANDICAP DEBUG] Calculating differentials (checking course_id and fetching par)...`);
                // Loop through the fetched game documents
                for (const gameDoc of gamesSnapshot.docs) {
                    const gameData = gameDoc.data();
                    const score = gameData.score;
                    const courseId = gameData.course_id; // Get course ID from the game data
                    const holesPlayed = gameData.holes_played || '18'; // Default to 18 if not specified

                    // --- Check if course_id exists BEFORE trying to use it ---
                    if (!courseId) {
                        console.log(`[HANDICAP DEBUG] Skipping game ${gameDoc.id}: Missing course_id.`);
                        continue; // Skip this game if no course is associated
                    }
                    // --- End Check ---

                    // Check if score is a valid number
                    if (typeof score !== 'number') {
                         console.log(`[HANDICAP DEBUG] Skipping game ${gameDoc.id}: Invalid score type (${typeof score}).`);
                         continue; // Skip if score isn't a number
                    }

                    // Use the consolidated helper function to get course par, passing the specific cache
                    const coursePar = await getCourseParById(courseId, handicapCalcCache);

                    // Check if par was successfully retrieved
                    if (typeof coursePar !== 'number') {
                         console.log(`[HANDICAP DEBUG] Skipping game ${gameDoc.id}: Could not get valid par for course ${courseId}.`);
                         continue; // Skip if par is invalid or couldn't be fetched
                    }

                    // Adjust par if it was a 9-hole round (using simplistic halving)
                    let parForRound = coursePar;
                    if (holesPlayed === '9F' || holesPlayed === '9B') {
                        parForRound = Math.round(coursePar / 2);
                    }

                    // Calculate the differential for this round
                    const differential = score - parForRound;
                    differentials.push(differential); // Add the valid differential to the list
                    console.log(`[HANDICAP DEBUG] Game ${gameDoc.id}: Score=${score}, Par=${parForRound}, Holes=${holesPlayed}, Diff=${differential}`);
                } // End loop through games

                // --- Step 4: Calculate the average of ALL valid differentials ---
                if (differentials.length === 0) {
                     console.log(`[HANDICAP DEBUG] No valid differentials calculated (after checking course_id/par). Exiting.`);
                     return; // Keep existing handicap if no valid differentials found
                }

                // Calculate the sum and average
                const sumOfDifferentials = differentials.reduce((sum, diff) => sum + diff, 0);
                const calculatedHandicap = sumOfDifferentials / differentials.length;

                // Round the final average handicap to one decimal place
                const finalHandicap = Math.round(calculatedHandicap * 10) / 10;

                console.log(`[HANDICAP DEBUG] Final Handicap Calculated: ${finalHandicap} (Avg of [${differentials.join(', ')}])`);

                // --- Step 5: Update Firestore ---
                const playerRef = db.collection('players').doc(playerId);
                console.log(`[HANDICAP DEBUG] Preparing Firestore update for player ${playerId}: { golf_handicap: ${finalHandicap} }`);
                try {
                    // Attempt to update the player document
                    await playerRef.update({ golf_handicap: finalHandicap });
                    console.log(`[HANDICAP DEBUG] Firestore update successful for player ${playerId}.`); // Log success

                } catch (updateError) {
                    console.error(`[HANDICAP DEBUG] Firestore update FAILED for player ${playerId}:`, updateError); // Log failure details
                    // Alert user about the failure to save
                    alert(`Failed to save calculated handicap: ${updateError.message}`);
                    return; // Stop if the update fails
                }
                // --- End Firestore Update ---

                // --- Optional: Refresh rankings if currently viewing ---
                if (rankingsGameFilter?.value === 'golf' && document.getElementById('rankings-section') && !document.getElementById('rankings-section').classList.contains('hidden')) {
                     console.log("[HANDICAP DEBUG] Refreshing golf rankings display.");
                     await populateGameRankings('golf'); // Refresh the rankings table
                }
                console.log(`[HANDICAP DEBUG] === Calculation finished successfully for player ${playerId} ===`);

            } catch (error) {
                console.error(`[HANDICAP DEBUG] === Error during calculation process for player ${playerId}:`, error);
                 // Check if the error is related to indexes for the query
                 if (error.code === 'failed-precondition' || error.message.includes('index')) {
                     console.error("Firestore index likely needed for the handicap query: games collection, fields: player_id (==), game_type (==), date_played (desc). Please create this index in your Firebase console.");
                     alert("Error calculating handicap: A database index might be missing. Please check the console.");
                 } else {
                    // General error during the process
                    alert(`An error occurred while calculating the handicap: ${error.message}`);
                 }
            }
        }
        function closePlayerModal() {
             if (playerInfoModal) {
                 playerInfoModal.classList.remove('active');
                 playerInfoModal.classList.remove('modal-editing'); // Reset edit state
                 playerInfoModal.removeAttribute('data-current-player-id'); // Clear stored ID
                 document.body.style.overflow = ''; // Restore background scrolling
             }
        }
        // --- Function to populate recent activity in player modal ---
        // --- Function to populate recent activity in player modal (Modified for Golf Differential) ---
// --- Function to populate recent activity in player modal (Refactored for Global Cache & Golf) ---
async function populatePlayerRecentActivity(activityElement, playerId, limit = 5) { // Make async
            if (!db || !playerId || !activityElement) {
                 console.warn("[Player Activity] Missing DB, playerId, or activityElement.");
                 if(activityElement) activityElement.innerHTML = '<li class="text-gray-500">Could not load activity (missing parameters).</li>';
                 return;
            }

            // Ensure global player cache is populated
            if (!playersCachePopulated) {
                console.warn("[Player Activity] Player cache not populated. Activity may lack names.");
                // Attempting a fetch here might be slow for a modal open.
                // Relying on initialization or section navigation to populate cache.
                // Displaying an error might be better if names are crucial.
                activityElement.innerHTML = '<li class="text-orange-500">Loading activity (player data might be pending)...</li>';
                // Consider adding a small delay and re-checking, or just proceed without full names initially.
                // For simplicity, we'll proceed, names might show as 'Unknown'.
            } else {
                 activityElement.innerHTML = '<li class="text-gray-500">Loading activity...</li>';
            }


            // --- Optional: Course Par Cache (Specific to this function's context) ---
            // This remains useful if you don't have a global course cache
            const courseParCacheActivity = {};
            const getCourseParActivity = async (courseId) => {
                 if (!courseId) return null;
                 if (courseParCacheActivity[courseId] !== undefined) return courseParCacheActivity[courseId]; // Check cache
                 try {
                     const courseDoc = await db.collection('golf_courses').doc(courseId).get();
                     if (courseDoc.exists) {
                         const par = courseDoc.data().total_par;
                         if (typeof par === 'number') {
                             courseParCacheActivity[courseId] = par; return par;
                         } else { courseParCacheActivity[courseId] = null; }
                     } else { courseParCacheActivity[courseId] = null; }
                 } catch (err) { console.error(`Error fetching course ${courseId} for activity:`, err); }
                 return null; // Return null on error or not found
            };
            // --- End Course Par Cache ---

            try {
                // Firestore Index Required: games: participants (Array), date_played (Descending)
                const gamesQuery = db.collection('games')
                                    .where('participants', 'array-contains', playerId)
                                    .orderBy('date_played', 'desc')
                                    .limit(limit);
                const snapshot = await gamesQuery.get();

                if (snapshot.empty) {
                     activityElement.innerHTML = '<li class="text-gray-500 italic">No recent activity found.</li>';
                     return;
                }
                activityElement.innerHTML = ''; // Clear loading/pending message

                // DELETE the local playerCacheModal and getPlayerNameModal
                // - const playerCacheModal = {};
                // - const getPlayerNameModal = async (pid) => { ... };

                // Get current player's name from GLOBAL cache
                const currentPlayerName = globalPlayerCache[playerId]?.name || 'Unknown Player'; // Use global cache

                // Process each game document
                for (const doc of snapshot.docs) { // Loop is synchronous for player names
                     const game = { id: doc.id, ...doc.data() };
                     let description = ""; // Will be built below
                     const gameDate = game.date_played?.toDate ? game.date_played.toDate().toLocaleDateString() : 'Unknown Date';
                     const gameType = gameTypesConfig[game.game_type] || game.game_type || 'Unknown Game';
                     const participants = game.participants || [];


                     // --- Build Description Differently for Golf ---
                     if (game.game_type === 'golf') {
                         description = `Played ${gameType}`;
                         let diffString = ''; // Placeholder for differential string
                         // Check if score exists and is a number
                         if (typeof game.score === 'number') {
                             // If course ID exists, try to calculate differential
                             if (game.course_id) {
                                 const coursePar = await getCourseParActivity(game.course_id); // Use local cache helper
                                 if (typeof coursePar === 'number') {
                                     let parForRound = coursePar;
                                     if (game.holes_played === '9F' || game.holes_played === '9B') {
                                         parForRound = Math.round(coursePar / 2);
                                     }
                                     const differential = game.score - parForRound;
                                     let diffClass = 'text-gray-600'; // Default for Even
                                     let diffPrefix = '';
                                     if (differential > 0) {
                                         diffClass = 'text-red-600'; // Over par
                                         diffPrefix = '+';
                                     } else if (differential < 0) {
                                         diffClass = 'text-green-600'; // Under par
                                     }
                                     const diffDisplay = differential === 0 ? 'E' : `${diffPrefix}${differential}`;
                                     // Add Score/Par/Diff to description
                                     description += ` (${game.score}/${parForRound} | <span class="font-semibold ${diffClass}">${diffDisplay}</span>)`;
                                 } else {
                                     // Only show score if par wasn't found but course ID existed
                                     description += ` (${game.score} on unknown course)`;
                                 }
                             } else {
                                 // Show score if no course ID was recorded
                                 description += ` (${game.score}, no course info)`;
                             }
                         } else {
                              // If score itself wasn't recorded
                              description += ` (score not recorded)`;
                         }
                     } else {
                         // --- Non-Golf Description Logic (Using Global Cache) ---
                         // Get participant names from GLOBAL cache
                         const participantNames = participants.map(id => globalPlayerCache[id]?.name || 'Unknown Player'); // Use global cache

                         if (game.outcome === 'Win/Loss' && participantNames.length >= 2) {
                            const winnerName = participantNames[0]; // Assumes order is winner, loser based on save logic
                            const loserName = participantNames[1];
                            // Check against the globally cached name for the current player
                            if (winnerName === currentPlayerName) { description = `Beat ${loserName} in ${gameType}`; }
                            else if (loserName === currentPlayerName) { description = `Lost to ${winnerName} in ${gameType}`; }
                            else { description = `${winnerName} beat ${loserName} in ${gameType}`; } // Game current player wasn't part of? (Shouldn't happen with query)
                         } else if (game.outcome === 'Draw' && participantNames.length >= 2) {
                            // Find opponent name using the globally cached names
                            const opponentName = participantNames.find(name => name !== currentPlayerName && name !== 'Unknown Player') || 'opponent';
                            description = `Drew against ${opponentName} in ${gameType}`;
                         } else {
                             // Fallback if outcome isn't Win/Loss/Draw or participants !== 2
                             const otherPlayerNames = participantNames.filter(name => name !== currentPlayerName).join(', ');
                             description = `Played ${gameType}${otherPlayerNames ? ' with ' + otherPlayerNames : ''}`;
                         }
                         if (game.score) description += ` (${game.score})`; // Append score if available
                     }
                     // --- End Description Building ---

                    const li = document.createElement('li');
                    li.innerHTML = `<span class="text-gray-500 text-xs mr-2">[${gameDate}]</span> ${description}`;
                    activityElement.appendChild(li);
                } // End loop

            } catch (error) {
                console.error(`Error fetching recent activity for player ${playerId}:`, error);
                 // Check for index error
                 if (error.code === 'failed-precondition') {
                     activityElement.innerHTML = `<li class="text-red-500">Error: Firestore index missing for activity query. Check console.</li>`;
                     console.error("Firestore index needed: games collection, fields: participants (array-contains), date_played (desc).");
                 } else {
                    activityElement.innerHTML = `<li class="text-red-500">Error loading activity: ${error.message}</li>`;
                 }
            }
        }


        // --- Record Game Modal Functions ---
       // --- Record Game Modal Functions (Modified for Golf) ---
       // --- Record Game Modal Functions (Modified for Detailed Golf Entry) ---
// --- Record Game Modal Functions (Refactored for Single Player Fetch & Golf) ---
// --- Record Game Modal Functions (Refactored for Single Player Fetch, Golf, and Generic Modal) ---
async function openRecordGameModal() { // Make the function async
            // Get the specific modal container element
            const modalElement = document.getElementById('record-game-modal');
            if (!modalElement) {
                console.error("Record game modal container (#record-game-modal) not found.");
                alert("Error: Cannot open Record Game form.");
                return;
            }
            if (!db) {
                console.error("Record game modal: DB not ready.");
                alert("Error: Cannot open Record Game form. Database might not be connected.");
                return;
            }

            // --- Fetch Players ONCE ---
            console.log("[MODAL Record] Fetching players for dropdowns...");
            const allPlayers = await getAllPlayers(); // Fetch the player list
            if (!allPlayers || allPlayers.length === 0) {
                 console.warn("[MODAL Record] No players fetched, dropdowns will be empty.");
                 alert("Warning: No players found in the database. Cannot record game involving players.");
                 // Consider not opening the modal or showing a specific error state
            }
            console.log(`[MODAL Record] Got ${allPlayers.length} players.`);
            // --- End Fetch Players ---

            // Define and Inject the specific HTML content for this modal
            const modalContentHTML = `
                <div class="modal-content">
                    <button id="close-record-game-modal-btn" class="modal-close-button">&times;</button>
                    <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Record Game Result</h2>
                    <form id="record-game-form">

                        <div class="mb-4">
                            <label for="game-type-select-modal" class="block text-gray-700 text-sm font-bold mb-2">Game Type:</label>
                            <select id="game-type-select-modal" name="game-type" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                                <option value="">Select Game Type</option>
                                
                            </select>
                        </div>

                        
                        <div class="mb-4 standard-game-field" style="display: none;">
                            <label for="winner_player" class="block text-gray-700 text-sm font-bold mb-2">Winner:</label>
                            <select id="winner_player" name="winner_player" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700">
                                
                            </select>
                        </div>
                        <div class="mb-4 standard-game-field" style="display: none;">
                            <label for="loser_player" class="block text-gray-700 text-sm font-bold mb-2">Loser:</label>
                            <select id="loser_player" name="loser_player" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700">
                                
                            </select>
                        </div>
                        <div class="mb-4 standard-game-field" style="display: none;">
                             <label class="inline-flex items-center">
                                <input type="checkbox" id="is_draw" name="is_draw" class="form-checkbox h-5 w-5 text-blue-600">
                                <span class="ml-2 text-gray-700">Record as a Draw?</span>
                             </label>
                         </div>
                       


                        
                        <div id="golf-specific-options" class="golf-specific" style="display: none;">
                             <div class="mb-4 border border-gray-200 p-4 rounded-lg bg-gray-50">
                                <div class="mb-3">
                                    <span class="block text-gray-700 text-sm font-bold mb-2">Holes Played:*</span>
                                    <div class="flex space-x-4">
                                        <label class="inline-flex items-center">
                                            <input type="radio" name="golf-holes-played" value="18" class="form-radio h-4 w-4 text-indigo-600" checked>
                                            <span class="ml-2 text-sm">18 Holes</span>
                                        </label>
                                        <label class="inline-flex items-center">
                                            <input type="radio" name="golf-holes-played" value="9F" class="form-radio h-4 w-4 text-indigo-600">
                                            <span class="ml-2 text-sm">Front 9</span>
                                        </label>
                                        <label class="inline-flex items-center">
                                            <input type="radio" name="golf-holes-played" value="9B" class="form-radio h-4 w-4 text-indigo-600">
                                            <span class="ml-2 text-sm">Back 9</span>
                                        </label>
                                    </div>
                                </div>
                                <div>
                                     <label class="inline-flex items-center">
                                        <input type="checkbox" id="golf-track-holes" name="golf-track-holes" class="form-checkbox h-5 w-5 text-indigo-600">
                                        <span class="ml-2 text-sm font-medium text-gray-800">Track Hole-by-Hole Scores?</span>
                                     </label>
                                </div>
                             </div>

                            
                             <div id="golf-player-select-container" class="mb-4"></div>
                             <div id="golf-course-select-container" class="mb-4"></div>

                             
                             <div id="golf-hole-scores-section" class="mt-4 pt-4 border-t" style="display: none;">
                                 <h3 class="text-lg font-semibold mb-3 text-indigo-600">Enter Hole Scores:</h3>
                                 <div id="golf-hole-inputs-container" class="grid grid-cols-3 sm:grid-cols-5 gap-3">
                                    
                                 </div>
                             </div>
                        </div>
                       


                       
                        <div class="mb-4">
                            <label for="score" class="block text-gray-700 text-sm font-bold mb-2">Score:</label>
                            <input type="text" id="score" name="score" placeholder="Calculated or Enter Total" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700">
                        </div>
                     

                        <div class="mt-6 flex justify-end space-x-3">
                            <button type="button" id="cancel-record-game-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                            <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-5 rounded-lg">Record Result</button>
                        </div>
                    </form>
                </div>`;
            modalElement.innerHTML = modalContentHTML; // Inject HTML

            // Get references to elements *inside* the newly added modal content
            const closeButton = modalElement.querySelector('#close-record-game-modal-btn');
            const cancelButton = modalElement.querySelector('#cancel-record-game-modal-btn');
            const modalForm = modalElement.querySelector('#record-game-form');
            const gameTypeSelect = modalElement.querySelector('#game-type-select-modal');
            // Standard game fields
            const stdGameFields = modalElement.querySelectorAll('.standard-game-field');
            const winnerSelect = modalElement.querySelector('#winner_player');
            const loserSelect = modalElement.querySelector('#loser_player');
            const winnerLabel = modalElement.querySelector('label[for="winner_player"]');
            const loserLabel = modalElement.querySelector('label[for="loser_player"]');
            const drawCheckbox = modalElement.querySelector('#is_draw');
            // Golf specific fields container
            const golfOptionsContainer = modalElement.querySelector('#golf-specific-options');
            const golfHolesRadios = modalElement.querySelectorAll('input[name="golf-holes-played"]');
            const golfTrackCheckbox = modalElement.querySelector('#golf-track-holes');
            const golfHoleScoresSection = modalElement.querySelector('#golf-hole-scores-section');
            const golfHoleInputsContainer = modalElement.querySelector('#golf-hole-inputs-container');
            const golfPlayerContainer = modalElement.querySelector('#golf-player-select-container');
            const golfCourseContainer = modalElement.querySelector('#golf-course-select-container');
            // Shared score field
            const scoreInput = modalElement.querySelector('#score');
            const scoreLabel = modalElement.querySelector('label[for="score"]');
            // --- End References ---


            // --- Helper Function to Generate Hole Inputs (defined inside openRecordGameModal) ---
            const generateHoleInputs = () => {
                if (!golfHoleInputsContainer || !golfHolesRadios || !golfTrackCheckbox) return;

                const trackScores = golfTrackCheckbox.checked;
                golfHoleScoresSection.style.display = trackScores ? 'block' : 'none';
                scoreInput.readOnly = trackScores; // Make total score read-only if tracking holes
                scoreInput.placeholder = trackScores ? 'Auto-calculated from holes' : 'Enter Total Score';
                scoreInput.classList.toggle('bg-gray-100', trackScores);

                golfHoleInputsContainer.innerHTML = ''; // Clear previous inputs

                if (trackScores) {
                    let startHole = 1;
                    let endHole = 18;
                    const holesValue = Array.from(golfHolesRadios).find(radio => radio.checked)?.value;

                    if (holesValue === '9F') { endHole = 9; }
                    else if (holesValue === '9B') { startHole = 10; endHole = 18; }

                    for (let i = startHole; i <= endHole; i++) {
                        const holeDiv = document.createElement('div');
                        holeDiv.innerHTML = `
                            <label for="hole-${i}" class="block text-xs font-medium text-gray-600 mb-1">Hole ${i}</label>
                            <input type="number" id="hole-${i}" name="hole-${i}" min="1" class="hole-score-input shadow-sm appearance-none border rounded w-full py-1 px-2 text-gray-700 text-sm leading-tight focus:outline-none focus:ring-1 focus:ring-indigo-400">
                        `;
                        golfHoleInputsContainer.appendChild(holeDiv);
                    }
                    // Add listener to recalculate total score when hole scores change
                    golfHoleInputsContainer.addEventListener('input', updateTotalScoreFromHoles);
                    updateTotalScoreFromHoles(); // Initial calculation
                } else {
                     golfHoleInputsContainer.removeEventListener('input', updateTotalScoreFromHoles);
                }
            };

            // --- Helper Function to Calculate Total Score from Hole Inputs (defined inside openRecordGameModal) ---
            const updateTotalScoreFromHoles = () => {
                if (!golfTrackCheckbox?.checked || !golfHoleInputsContainer || !scoreInput) return;
                let total = 0;
                golfHoleInputsContainer.querySelectorAll('.hole-score-input').forEach(input => {
                    const score = parseInt(input.value, 10);
                    if (!isNaN(score) && score > 0) {
                        total += score;
                    }
                });
                scoreInput.value = total > 0 ? total : ''; // Display total or empty if 0
            };

            // --- Function to update the entire form based on game type (defined inside openRecordGameModal) ---
            const updateFormForGameType = async (selectedGameType) => { // Mark async
                // Hide everything initially (except game type)
                stdGameFields.forEach(field => field.style.display = 'none');
                if (golfOptionsContainer) golfOptionsContainer.style.display = 'none';
                if (scoreInput) scoreInput.required = false; // Reset required status
                if (scoreLabel) scoreLabel.textContent = 'Score:';
                if (winnerSelect) winnerSelect.required = false;
                if (loserSelect) loserSelect.required = false;


                if (selectedGameType === 'golf') {
                    // --- Show GOLF options ---
                    console.log("[MODAL] Golf selected, showing golf options.");
                    if (golfOptionsContainer) golfOptionsContainer.style.display = 'block';

                    // Adjust Score Input for Golf
                    if (scoreLabel) scoreLabel.textContent = 'Total Score:*';
                    if (scoreInput) {
                         scoreInput.placeholder = 'Enter Total Score or Track Holes';
                         scoreInput.type = 'number';
                         scoreInput.min = '1';
                         scoreInput.required = true; // Required unless tracking hole-by-hole
                         scoreInput.value = '';
                         scoreInput.readOnly = false;
                         scoreInput.classList.remove('bg-gray-100');
                    }

                    // Inject Player Select HTML
                    if (golfPlayerContainer) {
                         golfPlayerContainer.innerHTML = `
                            <label for="golf_player" class="block text-gray-700 text-sm font-bold mb-2">Player:*</label>
                            <select id="golf_player" name="golf_player" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                                
                            </select>`;
                         // Populate Player Dropdown using the fetched list
                         const golfPlayerSelect = golfPlayerContainer.querySelector('#golf_player');
                         // Use the 'allPlayers' array fetched when the modal opened
                         populatePlayerDropdown(golfPlayerSelect, allPlayers, 'Select Player');
                    }

                     // Inject Course Select HTML
                     if (golfCourseContainer) {
                        golfCourseContainer.innerHTML = `
                            <label for="golf_course" class="block text-gray-700 text-sm font-bold mb-2">Course Played:*</label>
                            <select id="golf_course" name="golf_course" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                                <option value="">Loading Courses...</option>
                               
                            </select>`;
                        // Populate Course Dropdown (This still needs its own fetch logic)
                         const golfCourseSelect = golfCourseContainer.querySelector('#golf_course');
                         if (golfCourseSelect && db) {
                            try {
                                const snapshot = await db.collection('golf_courses').orderBy('name').get();
                                golfCourseSelect.innerHTML = '<option value="">Select Course</option>';
                                snapshot.forEach(doc => golfCourseSelect.add(new Option(`${doc.data().name} (Par ${doc.data().total_par || 'N/A'})`, doc.id)));
                                golfCourseSelect.add(new Option('Score Only (No Course Info)', 'none'));
                            } catch (e) { console.error("Error populating golf course dropdown:", e); golfCourseSelect.innerHTML = '<option value="">Error</option>';}
                         }
                    }
                    generateHoleInputs(); // Initialize hole inputs based on default selections

                } else if (selectedGameType) {
                    // --- Show STANDARD game options ---
                    console.log("[MODAL] Non-golf selected, showing standard options.");
                    stdGameFields.forEach(field => field.style.display = 'block');
                    if (winnerSelect) winnerSelect.required = true;
                    if (loserSelect) loserSelect.required = true;

                    // --- Populate Standard Dropdowns ---
                    // Use the 'allPlayers' array fetched when the modal opened
                    populatePlayerDropdown(winnerSelect, allPlayers, 'Select Winner');
                    populatePlayerDropdown(loserSelect, allPlayers, 'Select Loser');
                    // --- End Populate ---

                    if (drawCheckbox) drawCheckbox.checked = false; // Reset draw state
                    if (winnerLabel) winnerLabel.textContent = 'Winner:';
                    if (loserLabel) loserLabel.textContent = 'Loser:';

                    // Adjust Score Input for Standard Games
                    if (scoreLabel) scoreLabel.textContent = 'Score (Optional):';
                    if (scoreInput) {
                         scoreInput.placeholder = 'e.g. 8-3, 21-15';
                         scoreInput.type = 'text';
                         scoreInput.required = false;
                         scoreInput.value = '';
                         scoreInput.readOnly = false;
                         scoreInput.classList.remove('bg-gray-100');
                    }
                } else {
                     // No game type selected yet, keep standard/golf hidden
                    console.log("[MODAL] No game type selected.");
                    // Clear standard dropdowns if needed, though they are hidden
                    if (winnerSelect) winnerSelect.innerHTML = '<option value="">Select Winner</option>';
                    if (loserSelect) loserSelect.innerHTML = '<option value="">Select Loser</option>';
                }
            };
            // --- End of updateFormForGameType ---


            // --- Attach Event Listeners for elements INSIDE the modal ---
            // Use the *specific* close function which now calls the generic one
            if (closeButton) closeButton.addEventListener('click', closeRecordGameModal);
            if (cancelButton) cancelButton.addEventListener('click', closeRecordGameModal);
            // Form submission handler remains specific
            if (modalForm) modalForm.addEventListener('submit', handleRecordGameSubmit);

            // Game type change listener
            if (gameTypeSelect) {
                gameTypeSelect.addEventListener('change', (e) => updateFormForGameType(e.target.value));
            }

            // Draw checkbox listener (for standard games)
            if(drawCheckbox && winnerLabel && loserLabel && winnerSelect && loserSelect) {
                 drawCheckbox.addEventListener('change', (e) => {
                     const isChecked = e.target.checked;
                     if (gameTypeSelect.value !== 'golf') { // Only apply if not golf
                         winnerLabel.textContent = isChecked ? 'Player 1:' : 'Winner:';
                         loserLabel.textContent = isChecked ? 'Player 2:' : 'Loser:';
                     }
                 });
             }

             // Golf options listeners
             if (golfHolesRadios) {
                 golfHolesRadios.forEach(radio => radio.addEventListener('change', generateHoleInputs));
             }
             if (golfTrackCheckbox) {
                 golfTrackCheckbox.addEventListener('change', generateHoleInputs);
                 // If tracking is enabled, total score is not required directly
                 golfTrackCheckbox.addEventListener('change', (e) => {
                     if(scoreInput) scoreInput.required = !e.target.checked;
                 });
             }
             // --- End Listeners ---


            // --- Initial Setup ---
            // Populate game type dropdown
            if (gameTypeSelect) {
                populateSelectWithOptions(gameTypeSelect, gameTypesConfig, 'Select Game Type');
            }

            // Initial call to set up the form based on currently selected game type (if any)
            await updateFormForGameType(gameTypeSelect?.value || ''); // Await this call
            // --- End Initial Setup ---

            // Call the generic openModal function to show the modal
            openModal(modalElement);
       }

// --- Record Game Modal Functions (Refactored for Generic Modal) ---
function closeRecordGameModal() {
            // Get the specific modal container element
            const modalElement = document.getElementById('record-game-modal');
            if (!modalElement) {
                console.error("Record Game Modal element (#record-game-modal) not found when trying to close.");
                return;
            }
            // Call the generic closeModal function.
            // It handles hiding the modal, restoring scroll, and clearing the innerHTML
            // because 'record-game-modal' is included in the 'modalsToClear' array within closeModal.
            closeModal(modalElement);
        }
        // --- End Record Game Modal Functions (Refactored) ---


// --- Add Player Modal Functions ---
// --- Add Player Modal Functions (Refactored) ---
function openAddPlayerModal() {
            // Get the specific modal container element
            const modalElement = document.getElementById('add-player-modal');
            if (!modalElement) { console.error("Add Player modal element (#add-player-modal) not found."); return; }
            if (!db) { console.error("Firestore DB not ready for Add Player modal."); return; } // Keep DB check

            // 1. Define and Inject the specific HTML content for this modal
            const modalContentHTML = `
                <div class="modal-content">
                    <button id="close-add-player-modal-btn" class="modal-close-button">&times;</button>
                    <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Add New Player</h2>
                    <form id="add-player-form">
                        <div class="mb-4">
                            <label for="player-name" class="block text-gray-700 text-sm font-bold mb-2">Player Name:</label>
                            <input type="text" id="player-name" name="player-name" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" required>
                        </div>
                        <div class="mb-5">
                            <label for="player-icon-url" class="block text-gray-700 text-sm font-bold mb-2">Icon URL (Optional):</label>
                            <input type="url" id="player-icon-url" name="player-icon-url" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="https://example.com/icon.png">
                             <p class="text-xs text-gray-500 mt-1">Enter a URL for the player's avatar/icon.</p>
                        </div>
                        <div class="mt-6 flex justify-end space-x-3">
                            <button type="button" id="cancel-add-player-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                            <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-5 rounded-lg">Add Player</button>
                        </div>
                    </form>
                </div>`;
            modalElement.innerHTML = modalContentHTML;

            // 2. Get references to elements *inside* the newly added modal content
            const closeButton = modalElement.querySelector('#close-add-player-modal-btn');
            const cancelButton = modalElement.querySelector('#cancel-add-player-modal-btn');
            const modalForm = modalElement.querySelector('#add-player-form');

            // 3. Add event listeners for the modal's internal controls
            //    These now call the *specific* close function (which uses the generic one)
            if (closeButton) closeButton.addEventListener('click', closeAddPlayerModal);
            if (cancelButton) cancelButton.addEventListener('click', closeAddPlayerModal);
            if (modalForm) modalForm.addEventListener('submit', handleAddPlayerSubmit); // Form submit handler remains specific

            // 4. Call the generic openModal function
            openModal(modalElement);
        }
        // --- End Add Player Modal Functions (Refactored) ---
        // You already have this function defined:
        // function closeAddPlayerModal() { ... }

        // Ensure you also have the handleAddPlayerSubmit function defined elsewhere
        // async function handleAddPlayerSubmit(event) { ... }



        function closeAddPlayerModal() {
            const modalElement = document.getElementById('add-player-modal');
            // Call the generic closeModal function, which handles hiding,
            // restoring scroll, and clearing content for this modal ID.
            closeModal(modalElement);
        }





       // NEW Helper for populating participant checkboxes
    function populateParticipantChecklist(containerElement, playersArray, selectedParticipants = []) {
        if (!containerElement) {
            console.warn("populateParticipantChecklist: Container element not found.");
            return;
        }
        containerElement.innerHTML = ''; // Clear existing content
        if (!playersArray || playersArray.length === 0) {
            containerElement.innerHTML = '<p class="text-gray-500 p-2 italic">No players found.</p>';
            return;
        }
        playersArray.forEach(player => {
            const div = document.createElement('div');
            div.className = 'flex items-center';
            const isChecked = selectedParticipants.includes(player.id); // Check if player is already selected
            div.innerHTML = `
                <input type="checkbox" id="participant-${player.id}" name="participants" value="${player.id}" class="form-checkbox h-4 w-4 text-indigo-600" ${isChecked ? 'checked' : ''}>
                <label for="participant-${player.id}" class="ml-2 text-sm text-gray-700">${player.name || 'Unnamed'}</label>
            `;
            containerElement.appendChild(div);
        });
        console.log(`[UI] Populated participant checklist in ${containerElement.id || '(no id)'} with ${playersArray.length} players.`);
    }


    // --- Create Tournament Modal Functions (Refactored for Single Player Fetch) ---
    // --- Create Tournament Modal Functions (Refactored for Single Player Fetch & Generic Modal) ---
    async function openCreateTournamentModal() { // Make async
         // Get the specific modal container element
         const modalElement = document.getElementById('create-tournament-modal');
         if (!modalElement) {
             console.error("Create Tournament modal container (#create-tournament-modal) not found.");
             alert("Error: Cannot open Create Tournament form.");
             return;
         }
         if (!db) {
             console.error("Create Tournament modal: DB not ready.");
             alert("Error: Cannot open Create Tournament form. Database might not be connected.");
             return;
         }

         // --- Fetch Players ONCE ---
         console.log("[MODAL Create Tournament] Fetching players for checklist...");
         const allPlayers = await getAllPlayers(); // Fetch the player list
         if (!allPlayers || allPlayers.length === 0) {
              console.warn("[MODAL Create Tournament] No players fetched, checklist will be empty.");
              alert("Warning: No players found in the database. Cannot create tournament without players.");
              // Optionally don't open the modal or show an error state
         }
         console.log(`[MODAL Create Tournament] Got ${allPlayers.length} players.`);
         // --- End Fetch Players ---

         // Define and Inject the specific HTML content for this modal
         const modalContentHTML = `
            <div class="modal-content">
                <button id="close-create-tournament-modal-btn" class="modal-close-button">&times;</button>
                <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Create New Tournament</h2>
                <form id="create-tournament-form">
                     <div class="mb-5">
                         <label for="tournament-name" class="block text-gray-700 text-sm font-bold mb-2">Tournament Name:</label>
                         <input type="text" id="tournament-name" name="tournament-name" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700" required>
                     </div>
                     <div class="mb-5">
                         <label for="tournament-game-type-select" class="block text-gray-700 text-sm font-bold mb-2">Game Type:</label>
                         <select id="tournament-game-type-select" name="tournament-game-type" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                             <option value="">Select Type</option>
                            
                         </select>
                     </div>
                     <div class="mb-5">
                         <label for="tournament-format" class="block text-gray-700 text-sm font-bold mb-2">Format:</label>
                         <select id="tournament-format" name="tournament-format" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                             <option value="">Select Format</option>
                             <option value="single-elim">Single Elimination</option>
                             <option value="double-elim">Double Elimination</option>
                             <option value="round-robin">Round Robin</option>
                         </select>
                     </div>
                     <div class="mb-5">
                         <label for="tournament-start-date" class="block text-gray-700 text-sm font-bold mb-2">Start Date (Optional):</label>
                         <input type="date" id="tournament-start-date" name="tournament-start-date" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700">
                     </div>
                     <div class="mb-5">
                         <label class="block text-gray-700 text-sm font-bold mb-2">Participants:</label>
                         <div id="tournament-participants-list" class="h-40 border rounded-lg p-3 overflow-y-auto bg-gray-50 space-y-2">
                            
                             <p class="text-gray-500 p-2">Loading participants...</p>
                         </div>
                         <p class="text-xs text-gray-500 mt-1">Select participants. Seeding may be based on current rankings for the selected game type.</p>
                     </div>
                     <div class="mt-6 flex justify-end space-x-3">
                         <button type="button" id="cancel-create-tournament-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                         <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-5 rounded-lg shadow hover:shadow-md">Create Tournament</button>
                     </div>
                 </form>
            </div>`;

        modalElement.innerHTML = modalContentHTML; // Inject HTML

        // Get references to elements *inside* the newly added modal content
        const closeButton = modalElement.querySelector('#close-create-tournament-modal-btn');
        const cancelButton = modalElement.querySelector('#cancel-create-tournament-modal-btn');
        const modalForm = modalElement.querySelector('#create-tournament-form');
        const gameTypeSelect = modalForm.querySelector('#tournament-game-type-select');
        const participantsContainer = modalForm.querySelector('#tournament-participants-list');

        // Attach Event Listeners for elements INSIDE the modal
        // Use the *specific* close function which now calls the generic one
        if (closeButton) closeButton.addEventListener('click', closeCreateTournamentModal);
        if (cancelButton) cancelButton.addEventListener('click', closeCreateTournamentModal);
        // Form submission handler remains specific
        if (modalForm) {
            modalForm.addEventListener('submit', handleCreateTournamentSubmit);
            // Populate game type dropdown dynamically
            if (gameTypeSelect) {
                populateSelectWithOptions(gameTypeSelect, gameTypesConfig, 'Select Type');
            }
            // Initial population of the participant checklist using the fetched players
            if (participantsContainer) {
                // Use the 'allPlayers' array fetched when the modal opened
                populateParticipantChecklist(participantsContainer, allPlayers);
            } else {
                 console.error("Participant container not found in Create Tournament modal.");
            }
        }

        // Call the generic openModal function to show the modal
        openModal(modalElement);
    }
    // --- End Create Tournament Modal Functions (Refactored) ---

    // REMEMBER TO DELETE the old populateTournamentParticipantsSelect function from your code.
// --- Create Tournament Modal Functions (Refactored for Generic Modal) ---
function closeCreateTournamentModal() {
            // Get the specific modal container element
            const modalElement = document.getElementById('create-tournament-modal');
            if (!modalElement) {
                console.error("Create Tournament modal element (#create-tournament-modal) not found when trying to close.");
                return;
            }
            // Call the generic closeModal function.
            // It handles hiding the modal, restoring scroll, and clearing the innerHTML
            // because 'create-tournament-modal' is included in the 'modalsToClear' array within closeModal.
            closeModal(modalElement);
        }
        // --- End Create Tournament Modal Functions (Refactored) ---

        // --- Add Game Modal Functions ---
       // --- Add Game Modal Functions (Refactored for Generic Modal) ---
       function openAddGameModal() {
            // Get the specific modal container element
            const modalElement = document.getElementById('add-game-modal');
            if (!modalElement) {
                 console.error("Add Game modal element (#add-game-modal) not found.");
                 alert("Error: Cannot open Add Game form.");
                 return;
            }
            // Note: DB check might not be strictly needed just to open the form,
            // but it's good practice if the form relies on DB data later.
            if (!db) {
                 console.warn("Add Game modal: DB not ready (may be needed for validation/submit).");
                 // Optionally alert("Database connection error. Cannot fully use Add Game form.");
            }

            // Define and Inject the specific HTML content for this modal
            const modalContentHTML = `
                <div class="modal-content">
                    <button id="close-add-game-modal-btn" class="modal-close-button">&times;</button>
                    <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Add New Game Type</h2>
                    <form id="add-game-form">
                        <div class="mb-4">
                            <label for="new-game-key" class="block text-gray-700 text-sm font-bold mb-2">Game Key:</label>
                            <input type="text" id="new-game-key" name="new-game-key" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" required pattern="[a-z0-9_]+" placeholder="e.g. foosball, table_tennis (lowercase, underscores)">
                            <p class="text-xs text-gray-500 mt-1">Use lowercase letters, numbers, and underscores only. This is used internally.</p>
                        </div>
                         <div class="mb-5">
                            <label for="new-game-name" class="block text-gray-700 text-sm font-bold mb-2">Display Name:</label>
                            <input type="text" id="new-game-name" name="new-game-name" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500" required placeholder="e.g. Foosball, Table Tennis">
                             <p class="text-xs text-gray-500 mt-1">This name appears in dropdowns and headings.</p>
                        </div>
                        <div class="mt-6 flex justify-end space-x-3">
                            <button type="button" id="cancel-add-game-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                            <button type="submit" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-5 rounded-lg">Add Game</button>
                        </div>
                    </form>
                </div>`;

            modalElement.innerHTML = modalContentHTML; // Inject HTML

            // Get references to elements *inside* the newly added modal content
            const closeButton = modalElement.querySelector('#close-add-game-modal-btn');
            const cancelButton = modalElement.querySelector('#cancel-add-game-modal-btn');
            const modalForm = modalElement.querySelector('#add-game-form');

            // Attach Event Listeners for elements INSIDE the modal
            // Use the *specific* close function which now calls the generic one
            if (closeButton) closeButton.addEventListener('click', closeAddGameModal);
            if (cancelButton) cancelButton.addEventListener('click', closeAddGameModal);
            // Form submission handler remains specific
            if (modalForm) modalForm.addEventListener('submit', handleAddGameSubmit);

            // Call the generic openModal function to show the modal
            openModal(modalElement);
        }
        // --- End Add Game Modal Functions (Refactored) ---

// --- Add Game Modal Functions (Refactored for Generic Modal) ---
function closeAddGameModal() {
             // Get the specific modal container element
             const modalElement = document.getElementById('add-game-modal');
             if (!modalElement) {
                 console.error("Add Game modal element (#add-game-modal) not found when trying to close.");
                 return;
             }
             // Call the generic closeModal function.
             // It handles hiding the modal, restoring scroll, and clearing the innerHTML
             // because 'add-game-modal' is included in the 'modalsToClear' array within closeModal.
             closeModal(modalElement);
        }
        // --- End Add Game Modal Functions (Refactored) ---


        // --- Populate Dropdowns from Firestore ---


        // Populates the participant checklist in the Create Tournament modal
        async function populateTournamentParticipantsSelect() {
             const participantsContainer = document.getElementById('tournament-participants-list');
             const gameTypeSelect = document.getElementById('tournament-game-type-select'); // Check if game type is selected

             if (!participantsContainer || !gameTypeSelect) {
                 console.warn("Cannot populate tournament participants: elements missing.");
                 if(participantsContainer) participantsContainer.innerHTML = '<p class="text-gray-500 p-2">Error initializing participant list.</p>';
                 return;
             }

             const selectedGameType = gameTypeSelect.value;
             participantsContainer.innerHTML = '<p class="text-gray-500 p-2">Loading participants...</p>';

             // Currently only supports individual players (1v1, FFA)
             // TODO: Extend to support teams if needed
             if (selectedGameType) { // Only load if a game type is selected
                 try {
                     if (!db) throw new Error("DB not connected");
                     const snapshot = await db.collection('players').orderBy('name').get();
                     if (snapshot.empty) {
                         participantsContainer.innerHTML = '<p class="text-gray-500 p-2">No players found.</p>';
                     } else {
                         participantsContainer.innerHTML = ''; // Clear loading message
                         snapshot.forEach(doc => {
                             const player = { id: doc.id, ...doc.data() };
                             const div = document.createElement('div');
                             div.className = 'flex items-center';
                             div.innerHTML = `
                                 <input type="checkbox" id="participant-${player.id}" name="participants" value="${player.id}" class="form-checkbox h-4 w-4 text-indigo-600">
                                 <label for="participant-${player.id}" class="ml-2 text-sm text-gray-700">${player.name || 'Unnamed'}</label>
                             `;
                             participantsContainer.appendChild(div);
                         });
                     }
                 } catch (error) {
                     console.error("Error fetching players for tournament:", error);
                     participantsContainer.innerHTML = '<p class="text-red-500 p-2">Error loading players.</p>';
                 }
             } else {
                  participantsContainer.innerHTML = '<p class="text-gray-500 p-2">Select a game type first.</p>';
             }
         }

        // --- Results Table Population (Firestore) ---
        // --- Results Table Population (Firestore) (Modified for Golf) ---
// --- Results Table Population (Firestore) (Modified for Golf & Actions Column Removed) ---
// --- Results Table Population (Firestore) (Modified for Golf & Added Gear Icon) ---
// --- Results Table Population (Firestore) (Modified for Golf & Added Gear Icon) ---
// --- Results Table Population (Firestore) (Refactored for Global Cache & Golf) ---
async function populateResultsTable() { // Make async
            // Ensure the table body element exists
            if (!resultsTableBody) {
                console.error("[RESULTS] Table body 'results-table-body' not found.");
                return;
            }
            // Ensure Firestore DB is initialized
            if (!db) {
                console.error("[RESULTS] Firestore database (db) is not initialized.");
                resultsTableBody.innerHTML = '<tr><td colspan="4" class="text-red-500 text-center py-4">Database connection error.</td></tr>';
                return;
            }

            // Ensure cache is populated (with fetch attempt if needed)
            if (!playersCachePopulated) {
                console.warn("[RESULTS] Player cache not populated, attempting fetch...");
                await fetchAllPlayersForCache();
                if (!playersCachePopulated) {
                     console.error("[RESULTS] Failed to populate player cache. Cannot display results accurately.");
                     resultsTableBody.innerHTML = '<tr><td colspan="4" class="text-red-500 text-center py-4">Error loading player data for results.</td></tr>';
                     return; // Exit if cache still couldn't be populated
                }
            }

            console.log("[RESULTS] Populating results table using global cache...");
            // Update colspan to 4 for the loading message row
            resultsTableBody.innerHTML = '<tr><td colspan="4" class="text-gray-500 text-center py-4">Loading results...</td></tr>';

            try {
                const gamesCollection = db.collection('games');
                // Fetch games ordered by date, limit for performance
                // Requires index: games: date_played (desc)
                const snapshot = await gamesCollection.orderBy('date_played', 'desc').limit(50).get();

                // Handle case where no results are found
                if (snapshot.empty) {
                    // Update colspan to 4 for the empty results message row
                    resultsTableBody.innerHTML = '<tr><td colspan="4" class="text-gray-500 text-center py-4">No game results found.</td></tr>';
                    return;
                }

                // Clear the loading state before adding new rows
                resultsTableBody.innerHTML = '';

                // DELETE the local playerCache and getPlayerName function
                // - const playerCache = {};
                // - const getPlayerName = async (playerId) => { ... };

                 // Optional: Cache course names if displaying them (adds reads)
                 const courseCache = {}; // Keep this local if only used here
                 const getCourseName = async (courseId) => {
                    if (!courseId || courseId === 'none') return null; // Handle null or 'none' ID
                    if (courseCache[courseId]) return courseCache[courseId];
                    try {
                        const courseDoc = await db.collection('golf_courses').doc(courseId).get();
                        const name = courseDoc.exists ? courseDoc.data().name : 'Unknown Course';
                        courseCache[courseId] = name;
                        return name;
                    } catch (err) { console.warn(`[RESULTS] Error fetching course ${courseId}:`, err); return 'Error Loading Course'; }
                 };

                // Iterate through each game document and build a table row
                for (const doc of snapshot.docs) { // Loop is now synchronous regarding player name lookups
                    const game = { id: doc.id, ...doc.data() };
                    const tr = document.createElement('tr');
                    tr.className = 'border-b hover:bg-gray-50';
                    tr.setAttribute('data-game-id', game.id);

                    // Format the game date
                    let gameDateStr = 'N/A';
                    if (game.date_played && typeof game.date_played.toDate === 'function') {
                        try { gameDateStr = game.date_played.toDate().toLocaleDateString(); }
                        catch (e) { console.warn("Error formatting date:", e, game.date_played); }
                    }

                    // Get the display name for the game type from config, fallback to key
                    const gameTypeDisplay = gameTypesConfig[game.game_type] || game.game_type || 'N/A';

                    // Build the description string based on game type and outcome
                    let description = ''; // Initialize empty description

                    // --- Handle Golf Game Description ---
                    if (game.game_type === 'golf') {
                        // Use global cache directly
                        const playerName = globalPlayerCache[game.player_id]?.name || 'Unknown Player'; // Access cache
                        description = `${gameTypeDisplay}: <b>${playerName}</b> scored ${game.score || 'N/A'}`;
                        if (game.course_id && game.course_id !== 'none') {
                             const courseName = await getCourseName(game.course_id); // Course fetch might still be async if needed
                             if (courseName && courseName !== 'Error Loading Course' && courseName !== 'Unknown Course') { description += ` at ${courseName}`; }
                             else if (courseName === 'Error Loading Course' || courseName === 'Unknown Course'){ description += ` (on course ${game.course_id})`; }
                             else { description += ` (on course)`; } // Fallback if name is null/empty but ID exists
                        } else if (!game.course_id) { description += ` (no course info)`; } // Explicitly state no course info
                    }
                    // --- Handle Non-Golf Game Description ---
                    else {
                        description = gameTypeDisplay;
                        const participants = game.participants || [];
                        if (participants.length > 0) {
                            // Get names directly from cache
                            const participantNames = participants.map(id => globalPlayerCache[id]?.name || 'Unknown Player'); // Access cache
                            if (game.outcome === 'Win/Loss' && participantNames.length >= 2) { description = `${gameTypeDisplay}: <b>${participantNames[0]}</b> defeated ${participantNames[1]}`; }
                            else if (game.outcome === 'Draw' && participantNames.length >= 2) { description = `${gameTypeDisplay}: ${participantNames[0]} drew with ${participantNames[1]}`; }
                            else { description = `${gameTypeDisplay}: ${participantNames.join(' vs ')}`; } // Fallback for other cases or participant counts
                            if (game.score) { description += ` <span class="text-gray-600">(${game.score})</span>`; }
                        } else { description += ": Unknown Participants"; }
                    }


                    // Generate the HTML for the gear icon cell (conditionally visible via admin-only class)
                    const actionsCellContent = `
                        <div class="admin-only text-center">
                            <button class="text-lg text-gray-500 hover:text-blue-600 p-1 edit-delete-game-btn" data-game-id="${game.id}" title="Edit/Delete Game">‚öôÔ∏è</button>
                        </div>`;

                    // Populate the table row with the four cells (Date, Game Type, Description, Actions Gear)
                    tr.innerHTML = `
                        <td class="px-4 py-3 text-sm">${gameDateStr}</td>
                        <td class="px-4 py-3 text-sm">${gameTypeDisplay}</td>
                        <td class="px-4 py-3 text-sm">${description}</td>
                        <td class="px-2 py-3 text-sm">${actionsCellContent}</td>
                    `;
                    // Append the completed row to the table body
                    resultsTableBody.appendChild(tr);
                } // End of loop through game documents

                console.log(`[RESULTS] Populated results table with ${snapshot.size} games.`);

            } catch (error) {
                console.error("Error fetching games for results table:", error);
                 // Check for specific Firestore index error
                 if (error.code === 'failed-precondition') {
                     // Update colspan to 4 for the error message row
                     resultsTableBody.innerHTML = `<tr><td colspan="4" class="text-red-500 text-center py-4">Error: Firestore index missing for sorting results by date. Please check the console for details.</td></tr>`;
                     console.error("Firestore index required: 'games' collection, 'date_played' field (descending). Please create this index in your Firebase console.");
                 } else {
                    // Update colspan to 4 for the generic error message row
                    resultsTableBody.innerHTML = `<tr><td colspan="4" class="text-red-500 text-center py-4">Error loading results: ${error.message}</td></tr>`;
                 }
            }
        }

        // --- Manage Tournaments List Population (Placeholder/Future) ---
        async function populateManageTournamentsList() {
            // This function is currently not actively used but could be for a dedicated admin management page
            console.warn("populateManageTournamentsList function called but not fully implemented.");
        }


        // --- Action Handlers for Edit/Delete Buttons ---

        // --- RESULTS SECTION: Edit/Delete Game ---

        // This function fetches the game data and calls the function to open the edit modal
        async function handleEditGame(gameId) {
            console.log(`[EDIT GAME] Requesting edit for game ID: ${gameId}`);
            if (!db) {
                alert("Database connection error.");
                return;
            }
            try {
                // Get a reference to the specific game document in Firestore
                const gameRef = db.collection('games').doc(gameId);
                // Fetch the document data
                const docSnap = await gameRef.get();

                // Check if the document exists
                if (!docSnap.exists) {
                    alert("Error: Game data not found.");
                    console.error(`[EDIT GAME] Game document with ID ${gameId} not found.`);
                    return;
                }
                // Combine the ID and data into an object
                const gameData = { id: docSnap.id, ...docSnap.data() };
                console.log("[EDIT GAME] Fetched game data:", gameData);

                // Call the function to open the modal, passing the fetched data
                openEditGameModal(gameData); // <-- This opens the new edit modal

            } catch (error) {
                console.error("[EDIT GAME] Error fetching game details for edit:", error);
                alert(`Failed to load game details: ${error.message}`);
            }
        }

        // *** NEW FUNCTION: Opens the Edit Game Modal ***
        // *** Opens the Edit Game Modal (Handles Non-Golf Games, Includes Delete Button) ***
       // *** NEW FUNCTION: Opens the Edit Game Modal (Refactored for Single Player Fetch) ***
// *** NEW FUNCTION: Opens the Edit Game Modal (Refactored for Single Player Fetch & Generic Modal) ***
async function openEditGameModal(gameData) { // Make the function async
            // Get the modal container element (shared with record game)
            // Use a different variable name to avoid confusion with the record modal scope, though it's the same element
            const editModalElement = document.getElementById('record-game-modal');
            if (!editModalElement) {
                console.error("Edit game modal container (#record-game-modal) not found.");
                alert("Error: Cannot open Edit Game form.");
                return;
            }
            if (!db) {
                console.error("Edit game modal: DB not ready.");
                alert("Database connection error. Cannot open edit modal.");
                return;
            }

            // --- Fetch Players ONCE ---
            console.log("[MODAL Edit] Fetching players for dropdowns...");
            const allPlayers = await getAllPlayers(); // Fetch the player list
            if (!allPlayers || allPlayers.length === 0) {
                console.warn("[MODAL Edit] No players fetched, dropdowns will be empty.");
                alert("Warning: No players found in the database. Cannot edit game involving players.");
                // Optionally close or show error
            }
            console.log(`[MODAL Edit] Got ${allPlayers.length} players.`);
            // --- End Fetch Players ---

            // --- Prepare Data for Form Population ---
            const gameId = gameData.id; // Get game ID from the passed data
            const isDraw = gameData.outcome === 'Draw';
            // Consistently assign based on draw status or win/loss order.
            const player1Id = gameData.participants?.[0] || ''; // Assumes winner/player1 is first
            const player2Id = gameData.participants?.[1] || ''; // Assumes loser/player2 is second
            const gameType = gameData.game_type || '';
            const score = gameData.score || '';

            // Format the date_played timestamp into YYYY-MM-DD string for the input
            let gameDateStr = '';
            if (gameData.date_played && typeof gameData.date_played.toDate === 'function') {
                try {
                    const dateObj = gameData.date_played.toDate();
                    // Pad month and day with leading zeros if needed
                    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
                    const day = dateObj.getDate().toString().padStart(2, '0');
                    gameDateStr = `${dateObj.getFullYear()}-${month}-${day}`;
                } catch (e) {
                    console.warn("Error formatting date for input:", e, gameData.date_played);
                    gameDateStr = new Date().toISOString().split('T')[0]; // Default to today on error
                }
            } else {
                 console.warn("[EDIT GAME] Date missing or invalid in game data, defaulting to today for input.");
                 gameDateStr = new Date().toISOString().split('T')[0]; // Default to today if missing
            }

            // --- Define Modal HTML Content (with Delete Button) ---
            // Note: Assumes non-golf game editing. Adapting for golf would need more logic.
            const modalContentHTML = `
                <div class="modal-content">
                    <button id="close-edit-game-modal-btn" class="modal-close-button" title="Close">&times;</button>
                    <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Edit Game Result (ID: ${gameId})</h2>
                    <form id="edit-game-form" data-game-id="${gameId}">
                        <div class="mb-4">
                            <label for="edit-game-type-select-modal" class="block text-gray-700 text-sm font-bold mb-2">Game Type:</label>
                            <select id="edit-game-type-select-modal" name="game-type" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                                <option value="">Select Game Type</option>
                                
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="edit-player1" class="block text-gray-700 text-sm font-bold mb-2">${isDraw ? 'Player 1:' : 'Winner:'}</label>
                            <select id="edit-player1" name="player1" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                                
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="edit-player2" class="block text-gray-700 text-sm font-bold mb-2">${isDraw ? 'Player 2:' : 'Loser:'}</label>
                            <select id="edit-player2" name="player2" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                                
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="edit-score" class="block text-gray-700 text-sm font-bold mb-2">Score (Optional):</label>
                            <input type="text" id="edit-score" name="score" value="${score}" placeholder="e.g. 8-3, 21-15" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700">
                        </div>
                         <div class="mb-4">
                            <label for="edit-date_played" class="block text-gray-700 text-sm font-bold mb-2">Date Played:</label>
                            <input type="date" id="edit-date_played" name="date_played" value="${gameDateStr}" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700" required>
                        </div>
                        <div class="mb-4">
                             <label class="inline-flex items-center">
                                <input type="checkbox" id="edit-is_draw" name="is_draw" class="form-checkbox h-5 w-5 text-blue-600" ${isDraw ? 'checked' : ''}>
                                <span class="ml-2 text-gray-700">Is this a Draw?</span>
                             </label>
                         </div>

                        
                        <div class="mt-6 flex justify-between items-center">
                            
                            <button type="button" id="modal-delete-game-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-5 rounded-lg shadow hover:shadow-md">Delete</button>
                            
                            <div class="space-x-3">
                                <button type="button" id="cancel-edit-game-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                                <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-5 rounded-lg">Save Changes</button>
                            </div>
                        </div>
                    </form>
                </div>`;

            // Inject the HTML content into the modal container
            editModalElement.innerHTML = modalContentHTML;

            // --- Get References to New Modal Elements ---
            const closeButton = editModalElement.querySelector('#close-edit-game-modal-btn');
            const cancelButton = editModalElement.querySelector('#cancel-edit-game-modal-btn');
            const modalForm = editModalElement.querySelector('#edit-game-form');
            const drawCheckbox = editModalElement.querySelector('#edit-is_draw');
            const player1Select = editModalElement.querySelector('#edit-player1');
            const player2Select = editModalElement.querySelector('#edit-player2');
            const player1Label = editModalElement.querySelector('label[for="edit-player1"]');
            const player2Label = editModalElement.querySelector('label[for="edit-player2"]');
            const gameTypeSelect = editModalElement.querySelector('#edit-game-type-select-modal');
            const dateInput = editModalElement.querySelector('#edit-date_played');
            const deleteButton = editModalElement.querySelector('#modal-delete-game-btn');
            // --- End References ---

            // --- Attach Event Listeners ---
            // Use the *specific* close function for edit mode
            if (closeButton) closeButton.addEventListener('click', closeEditGameModal);
            if (cancelButton) cancelButton.addEventListener('click', closeEditGameModal);
            // Use the specific submit handler for editing
            if (modalForm) modalForm.addEventListener('submit', handleEditGameSubmit);

            // Add listener for the Delete button inside the modal
            if (deleteButton) {
                deleteButton.addEventListener('click', () => {
                    const currentFormGameId = modalForm.getAttribute('data-game-id');
                    if (currentFormGameId) {
                        // Pass null for tableRowElement since it's not directly available here
                        handleDeleteGame(currentFormGameId, null);
                    } else {
                        console.error("Could not find gameId to delete from modal.");
                        alert("Error: Cannot determine which game to delete.");
                    }
                });
            }

            // Add listener to Draw checkbox to update Winner/Loser labels
            if (drawCheckbox && player1Label && player2Label) {
                drawCheckbox.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;
                    player1Label.textContent = isChecked ? 'Player 1:' : 'Winner:';
                    player2Label.textContent = isChecked ? 'Player 2:' : 'Loser:';
                });
            }
            // --- End Listeners ---

            // --- Populate Form Fields ---
            try {
                // Populate Game Types dropdown and set current value
                if (gameTypeSelect) {
                    populateSelectWithOptions(gameTypeSelect, gameTypesConfig, 'Select Game Type');
                    gameTypeSelect.value = gameType; // Set selected game type
                } else { console.warn("Game type select not found in edit modal."); }

                // Populate Player dropdowns and set selected players
                if (player1Select && player2Select) {
                    // Use helper function and pass the pre-fetched player list AND selected values
                    populatePlayerDropdown(player1Select, allPlayers, 'Select Player', player1Id);
                    populatePlayerDropdown(player2Select, allPlayers, 'Select Player', player2Id);
                } else { console.warn("Player selects not found in edit modal."); }

                // Double-check date input value (already set via 'value' attribute, but good practice)
                if(dateInput) dateInput.value = gameDateStr;

            } catch (error) {
                console.error("[EDIT GAME] Error populating dropdowns or setting values:", error);
                alert("Error populating form fields. Please try again.");
                closeEditGameModal(); // Close if population fails critically
                return; // Stop further execution
            }
            // --- End Populate ---

            // --- Call Generic Open Function ---
            // This handles adding 'active' class and managing body overflow
            openModal(editModalElement);
        }


// *** NEW FUNCTION: Closes the Edit Game Modal (uses the same container) ***
function closeEditGameModal() {
            // Get the specific modal container element (same one used for record game)
            const editModalElement = document.getElementById('record-game-modal');
            if (!editModalElement) {
                 console.error("Edit/Record game modal container (#record-game-modal) not found when trying to close edit mode.");
                 return;
            }
            // Call the generic closeModal function.
            // It handles hiding the modal, restoring scroll, and clearing the innerHTML
            // because 'record-game-modal' is in the 'modalsToClear' array.
            closeModal(editModalElement);
        }

        // *** NEW FUNCTION: Handles the submission of the Edit Game form ***
        async function handleEditGameSubmit(event) {
            event.preventDefault(); // Prevent default page reload
            const form = event.target;
            const gameId = form.getAttribute('data-game-id'); // Get game ID stored on the form

            if (!db || !gameId) {
                alert("Error: Database connection or Game ID is missing.");
                return;
            }

            // --- Form Validation ---
            let isValid = true;
            form.querySelectorAll('select[required], input[required]').forEach(field => {
                field.classList.remove('border-red-500'); // Clear previous errors
                if (!field.value) {
                    isValid = false;
                    field.classList.add('border-red-500'); // Mark empty required fields
                }
            });
            const player1Select = form.querySelector('#edit-player1');
            const player2Select = form.querySelector('#edit-player2');
            const player1Id = player1Select.value;
            const player2Id = player2Select.value;
            const isDraw = form.querySelector('#edit-is_draw').checked;
            const gameType = form.querySelector('#edit-game-type-select-modal').value;
            const dateValue = form.querySelector('#edit-date_played').value; // Get date as YYYY-MM-DD string

            // Specific validation checks
            if (!gameType) {
                alert("Please select a game type.");
                form.querySelector('#edit-game-type-select-modal').classList.add('border-red-500');
                isValid = false;
            }
            if (!dateValue) {
                alert("Please select a date.");
                 form.querySelector('#edit-date_played').classList.add('border-red-500');
                isValid = false;
            }
            if (!isDraw && player1Id === player2Id) {
                alert("Winner and Loser cannot be the same player unless it's a draw.");
                player1Select.classList.add('border-red-500');
                player2Select.classList.add('border-red-500');
                isValid = false;
            } else if (isDraw && (!player1Id || !player2Id)) {
                // For draws, both players must be selected
                alert("Please select both players for a draw.");
                if (!player1Id) player1Select.classList.add('border-red-500');
                if (!player2Id) player2Select.classList.add('border-red-500');
                isValid = false;
            }
             if (!isValid) { alert("Please correct the errors in the form."); return; }
             // --- End Validation ---

             // Convert date string to Firebase Timestamp
             let firestoreDate;
             try {
                 // Use a specific time (like midday UTC) to avoid potential timezone shifts near midnight
                 const dateObj = new Date(dateValue + 'T12:00:00Z');
                 if (isNaN(dateObj.getTime())) throw new Error("Invalid date object created"); // Check if date is valid
                 firestoreDate = firebase.firestore.Timestamp.fromDate(dateObj);
             } catch(e) {
                 console.error("Error converting date string to Timestamp:", e);
                 alert("Invalid date format. Please ensure the date is correct (YYYY-MM-DD).");
                 form.querySelector('#edit-date_played').classList.add('border-red-500');
                 return;
             }

            // Prepare the data object for Firestore update
            const updatedGameData = {
                game_type: gameType,
                date_played: firestoreDate, // Use the converted timestamp
                score: form.querySelector('#edit-score').value.trim() || null, // Store score or null
                outcome: isDraw ? 'Draw' : 'Win/Loss',
                // Ensure participants are stored consistently:
                // - For Win/Loss: [winnerId, loserId]
                // - For Draw: [player1Id, player2Id] sorted alphabetically to ensure consistency
                participants: isDraw ? [player1Id, player2Id].sort() : [player1Id, player2Id],
                last_updated: firebase.firestore.FieldValue.serverTimestamp() // Add a timestamp for the update
            };

            console.log(`[EDIT GAME] Submitting updates for Game ID ${gameId}:`, updatedGameData);

            // **IMPORTANT**: Updating Elo scores based on edited results is complex.
            // You would need to:
            // 1. Get the *original* game data before the edit.
            // 2. Potentially reverse the Elo changes from the original result.
            // 3. Calculate and apply the Elo changes based on the *new* result.
            // This is omitted here for simplicity but is crucial for maintaining correct rankings.
            // Consider adding a warning or disabling Elo recalculation for edits initially.
            // alert("Warning: Elo scores are NOT recalculated automatically on edit in this version.");

            try {
                // Get a reference to the specific game document and update it
                const gameRef = db.collection('games').doc(gameId);
                await gameRef.update(updatedGameData);

                alert(`Game ${gameId} updated successfully! (Note: Elo rankings may need manual recalculation or a more complex update logic)`);
                closeEditGameModal(); // Close the modal on success
                await populateResultsTable(); // Refresh the results table to show changes
                await populateDashboard(); // Refresh dashboard as stats might change (if implemented)

            } catch (error) {
                console.error(`Error updating game ${gameId}:`, error);
                alert(`Failed to update game: ${error.message}`);
            }
        }


        // This function deletes the game - ensure it handles potential side effects (like Elo) if needed.
        // This function deletes the game - now also handles closing modal & refresh
        async function handleDeleteGame(gameId, tableRowElement) { // tableRowElement might be null if called from modal
             console.log(`[DELETE GAME] Requesting delete for game ID: ${gameId}`);
             if (!db) {
                 console.error("Firestore not initialized. Cannot delete game.");
                 alert("Database connection error.");
                 return;
             }
             if (!gameId) {
                 console.error("handleDeleteGame called without a valid gameId.");
                 alert("Error: Cannot determine which game to delete.");
                 return;
             }

             // Confirmation dialog remains important - include warning about Elo impact
             if (confirm(`Are you sure you want to delete game result ${gameId}?\n\nWARNING: This action currently DOES NOT automatically recalculate Elo rankings. Rankings might become inaccurate after deletion.`)) {
                 try {
                     // Perform the deletion in Firestore
                     await db.collection('games').doc(gameId).delete();
                     console.log(`[FIRESTORE] Firestore document deleted: games/${gameId}`);

                     // --- UI Refresh Sequence ---
                     alert(`Game ${gameId} deleted successfully.`);

                     // 1. Close the edit modal if it's currently open (safe to call even if not open)
                     closeEditGameModal();

                     // 2. Refresh the results table to remove the deleted row
                     // Ensure resultsTableBody is available before calling
                     if (resultsTableBody) {
                        await populateResultsTable();
                     } else {
                        console.warn("Results table body not found for refresh after delete.");
                     }

                     // 3. Refresh the dashboard (recent games, top players might change)
                     // Add checks for dashboard elements if necessary
                     await populateDashboard();

                     // 4. Refresh rankings if the rankings section is currently visible
                     // Ensure rankingsGameFilter is available
                     if (rankingsGameFilter && document.getElementById('rankings-section') && !document.getElementById('rankings-section').classList.contains('hidden')) {
                         await updateRankingsVisibility();
                     }
                     // --- End UI Refresh ---

                 } catch (error) {
                     console.error(`Error deleting game ${gameId}:`, error);
                     alert(`Failed to delete game ${gameId}. Error: ${error.message}. See console for details.`);
                 }
             } else {
                  console.log(`[DELETE GAME] Deletion cancelled for game ID: ${gameId}`);
             }
        }

        // --- Tournament Edit/Delete Placeholders ---
        function handleEditTournament(tournamentId) {
            console.log(`Edit tournament clicked: ${tournamentId}`);
            alert(`Edit functionality for tournament ${tournamentId} not implemented yet.`);
            // TODO: Implement tournament editing modal and logic
        }
        async function handleDeleteTournament(tournamentId, listItemElement) {
            console.log(`Delete tournament clicked: ${tournamentId}`);
            if (!db) { console.error("Firestore not initialized."); return; }
            if (confirm(`Are you sure you want to delete tournament '${tournamentId}'? This cannot be undone.`)) {
                 try {
                     await db.collection('tournaments').doc(tournamentId).delete();
                     console.log(`[FIRESTORE] Firestore document deleted: tournaments/${tournamentId}`);
                     if (listItemElement) listItemElement.remove(); // Remove from UI if in manage view
                     alert(`Tournament deleted.`);
                     // Refresh public tournament lists
                     await populateTournamentsList('dashboard-tournaments-list', 3);
                     await populateTournamentsList('tournaments-list-full');
                 } catch (error) {
                     console.error("Error deleting tournament:", error);
                     alert(`Failed to delete tournament ${tournamentId}. See console for details.`);
                 }
             }
        }
// Function to create a player profile document in Firestore
async function createPlayerProfile(authUid, email, playerName, iconUrl = null) {
    if (!db) return null;
    console.log(`Creating player profile for authUid: ${authUid}, name: ${playerName}`);
    try {
         // Check if a profile already exists for this authUid (important for Google Sign-In)
         const existing = await getPlayerProfileByAuthId(authUid);
         if(existing) {
             console.warn("Profile already exists for this auth user:", existing);
             return existing.id; // Return existing ID
         }

         // Initialize Elos (excluding golf) - similar to handleAddPlayerSubmit
         const initialElos = { overall: DEFAULT_ELO };
         ELO_GAME_KEYS.forEach(gameKey => {
             if (gameKey !== 'golf') {
                 initialElos[gameKey] = DEFAULT_ELO;
             }
         });

         const playerData = {
             authUid: authUid, // Link to Firebase Auth User ID
             email: email,     // Store email for reference
             name: playerName,
             iconUrl: iconUrl,
             elo_overall: DEFAULT_ELO,
             elos: initialElos,
             wins: 0, losses: 0, draws: 0, games_played: 0,
             golf_handicap: null,
             date_created: firebase.firestore.FieldValue.serverTimestamp()
         };

        const docRef = await db.collection('players').add(playerData);
        console.log("Player profile created successfully with ID:", docRef.id);
         if (playersGrid) await populatePlayersList(); // Refresh player list
        return docRef.id; // Return the new Firestore document ID

    } catch (error) {
        console.error("Error creating player profile:", error);
        alert(`Failed to create player profile: ${error.message}`);
        return null;
    }
}

// Function to get a player profile document by Auth UID
async function getPlayerProfileByAuthId(authUid) {
    if (!db || !authUid) return null;
    try {
        // Firestore index needed: players collection, authUid field (ascending)
        const querySnapshot = await db.collection('players').where('authUid', '==', authUid).limit(1).get();
        if (!querySnapshot.empty) {
            const doc = querySnapshot.docs[0];
            return { id: doc.id, ...doc.data() }; // Return profile data including Firestore ID
        } else {
            return null; // No profile found for this authUid
        }
    } catch (error) {
         if (error.code === 'failed-precondition') {
             console.error("Firestore index missing: players collection, field 'authUid' (ascending). Please create this index.");
             alert("Database error: Cannot retrieve player profile. Missing index (check console).");
         } else {
            console.error("Error fetching player profile by authUid:", error);
         }
         return null;
    }
}

        // --- Player Modal Edit Mode Handlers (Firestore) ---
        function togglePlayerModalEdit(editMode) {
            if (!playerInfoModal) return;
            if (editMode) {
                 playerInfoModal.classList.add('modal-editing');
                 playerInfoModal.querySelector('#modal-edit-player-name-input')?.focus(); // Focus name input
            } else {
                 playerInfoModal.classList.remove('modal-editing');
                 // Optionally reset input fields to original values if needed
            }
        }
        async function savePlayerChanges() {
            if (!playerInfoModal || !db) return;
            const playerId = playerInfoModal.getAttribute('data-current-player-id');
            if (!playerId) { alert("Error: No player ID found."); return; }

            const nameInput = playerInfoModal.querySelector('#modal-edit-player-name-input');
            const iconInput = playerInfoModal.querySelector('#modal-edit-player-icon-input');
            const newName = nameInput?.value.trim();
            const newIconUrl = iconInput?.value.trim() || null; // Store null if empty

            if (!newName) { alert("Player name cannot be empty."); nameInput?.focus(); return; }

            // Prepare data for update (only name and iconUrl are editable here)
            const updatedData = { name: newName, iconUrl: newIconUrl };

            try {
                 await db.collection('players').doc(playerId).update(updatedData);
                 alert("Player details updated successfully!");
                 togglePlayerModalEdit(false); // Switch back to view mode

                 // Update the displayed name and icon in the modal immediately
                 playerInfoModal.querySelector('#modal-player-name').textContent = newName;
                 const iconSrc = newIconUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(newName || '?')}&background=E0E7FF&color=4F46E5&size=80`;
                 playerInfoModal.querySelector('#modal-player-icon').src = iconSrc;

                 if (playersGrid) await populatePlayersList(); // Refresh player grid on the Players page

            } catch (error) {
                console.error(`Error updating player ${playerId}:`, error);
                alert(`Failed to update player: ${error.message}`);
            }
        }
        async function deletePlayer() {
             if (!playerInfoModal || !db) return;
             const playerId = playerInfoModal.getAttribute('data-current-player-id');
             const playerName = playerInfoModal.querySelector('#modal-player-name')?.textContent || 'this player';
             if (!playerId) { alert("Error: No player ID found."); return; }

             // IMPORTANT: Deleting a player has significant implications.
             // - Associated game results will reference a non-existent player.
             // - Tournament participation records might break.
             // - A "soft delete" (marking as inactive) is often safer in real applications.
             // This implementation performs a hard delete.
             if (confirm(`Are you sure you want to delete ${playerName} (${playerId})?\nWARNING: This cannot be undone and may affect historical game records.`)) {
                 try {
                     await db.collection('players').doc(playerId).delete();
                     alert(`${playerName} deleted successfully!`);
                     closePlayerModal(); // Close the modal

                     // Refresh relevant UI sections
                     if (playersGrid) await populatePlayersList();
                     await populateDashboard(); // Refresh dashboard (top players)
                     await populateResultsTable(); // Refresh results (player names might show as 'Unknown')
                     await updateRankingsVisibility(); // Refresh rankings

                 } catch (error) {
                     console.error(`Error deleting player ${playerId}:`, error);
                     alert(`Failed to delete player: ${error.message}`);
                 }
             }
        }

        // --- Dashboard Population ---
        async function populateDashboard() {
            console.log("[DASHBOARD] Populating...");
            if (!db) { console.warn("[DASHBOARD] DB not ready, skipping population."); return; }
            // Use Promise.all to load dashboard sections concurrently
            await Promise.all([
                populateRecentGamesList('recent-games-list', 5),
                populateTopPlayersList('top-players-list', 5), // Shows overall Elo
                populateTopTeamsList('top-teams-list', 5), // Placeholder for team rankings
                populateTournamentsList('dashboard-tournaments-list', 3) // Show recent tournaments
            ]);
            console.log("[DASHBOARD] Population complete.");
        }

        // --- Dashboard / Recent Games Population ---
        async function populateRecentGamesList(elementId = 'recent-games-list', limit = 5) {
            const listElement = document.getElementById(elementId);
            if (!listElement || !db) { console.warn(`Recent games list #${elementId} or DB not ready.`); return; }
            listElement.innerHTML = `<li class="text-gray-500">Loading recent games...</li>`;
            try {
                // Requires index: games: date_played (desc)
                const q = db.collection('games').orderBy('date_played', 'desc').limit(limit);
                const snapshot = await q.get();
                if (snapshot.empty) {
                    listElement.innerHTML = `<li class="text-gray-500">No games recorded yet.</li>`;
                    return;
                }
                listElement.innerHTML = ''; // Clear loading

                 // Cache player names for efficiency
                 const nameCache = {};
                 const getName = async (id) => {
                     if (!id) return 'N/A';
                     if (nameCache[id]) return nameCache[id];
                     try {
                         const doc = await db.collection('players').doc(id).get();
                         const name = doc.exists ? (doc.data().name || 'Unnamed') : 'Unknown';
                         nameCache[id] = name;
                         return name;
                     } catch (err) { return 'Error'; }
                 };

                // Process each recent game
                for (const doc of snapshot.docs) {
                    const game = { id: doc.id, ...doc.data() };
                    const gameDate = game.date_played?.toDate ? game.date_played.toDate().toLocaleDateString() : 'N/A';
                    const gameType = gameTypesConfig[game.game_type] || game.game_type || 'Game'; // Use config for display name
                    let description = gameType;

                    const participants = game.participants || [];
                    if (participants.length >= 2 && (game.outcome === 'Win/Loss' || game.outcome === 'Draw')) {
                        const p1Name = await getName(participants[0]);
                        const p2Name = await getName(participants[1]);
                        if (game.outcome === 'Win/Loss') {
                             // Assumes winner is first in 'participants' for Win/Loss
                             description = `${gameType}: <b>${p1Name}</b> beat ${p2Name}`;
                        } else { // Draw
                             description = `${gameType}: ${p1Name} drew with ${p2Name}`;
                        }
                    } else if (participants.length > 0) { // Fallback description
                        const names = await Promise.all(participants.map(id => getName(id)));
                        description = `${gameType}: ${names.join(', ')}`;
                    }
                    if (game.score) description += ` (${game.score})`; // Append score

                    const li = document.createElement('li');
                    li.className = 'border-b pb-2 mb-2 last:border-0 last:mb-0 last:pb-0 text-sm';
                    li.innerHTML = `
                        <div class="flex justify-between items-start">
                            <div>${description}</div>
                            <div class="text-gray-500 text-xs ml-2 whitespace-nowrap">${gameDate}</div>
                        </div>`;
                    listElement.appendChild(li);
                }
            } catch (error) {
                console.error(`Error fetching recent games for ${elementId}:`, error);
                 if (error.code === 'failed-precondition') {
                     listElement.innerHTML = `<li class="text-red-500">Error: Firestore index missing for date sorting. Check console.</li>`;
                     console.error("Firestore index needed: games collection, date_played (descending).");
                 } else {
                    listElement.innerHTML = `<li class="text-red-500">Error loading games: ${error.message}</li>`;
                 }
            }
        }

        // --- Dashboard / Top Players/Teams (Firestore based on Elo) ---
        async function populateTopPlayersList(elementId = 'top-players-list', limit = 5) {
             const listElement = document.getElementById(elementId);
             if (!listElement || !db) { console.warn(`Top players list #${elementId} or DB not ready.`); return; }
             listElement.innerHTML = '<li class="text-gray-500">Loading rankings...</li>';
             try {
                 // Requires index: players: elo_overall (desc)
                 const snapshot = await db.collection('players').orderBy('elo_overall', 'desc').limit(limit).get();
                 if (snapshot.empty) {
                     listElement.innerHTML = '<li class="text-gray-500">No players found.</li>'; return;
                 }
                 listElement.innerHTML = ''; // Clear loading
                 let rank = 1;
                 snapshot.forEach(doc => {
                     const player = doc.data();
                     const li = document.createElement('li');
                     li.className = "flex justify-between items-center";
                     li.innerHTML = `
                         <span>${rank}. ${player.name || 'Unnamed'}</span>
                         <span class="text-sm font-medium text-indigo-600">${Math.round(player.elo_overall || DEFAULT_ELO)}</span>`;
                     listElement.appendChild(li);
                     rank++;
                 });
             } catch (error) {
                 console.error(`Error fetching top players:`, error);
                  if (error.code === 'failed-precondition') {
                     listElement.innerHTML = `<li class="text-red-500">Error: Firestore index missing for overall Elo sorting. Check console.</li>`;
                     console.error("Firestore index needed: players collection, elo_overall (descending).");
                 } else {
                    listElement.innerHTML = `<li class="text-red-500">Error loading rankings.</li>`;
                 }
             }
        }
        async function populateTopTeamsList(elementId = 'top-teams-list', limit = 5) {
             // Placeholder - Team functionality not implemented
             const listElement = document.getElementById(elementId);
             if (listElement) {
                 listElement.innerHTML = '<li class="text-gray-500 italic">Team rankings not yet implemented.</li>';
             }
        }

        // --- Tournaments List Population (Dashboard & Tournaments Page) ---
        async function populateTournamentsList(listElementId, limit = 10) {
             const listElement = document.getElementById(listElementId);
             if (!listElement || !db) { console.warn(`Tournament list #${listElementId} or DB not ready.`); return; }
             listElement.innerHTML = `<li class="text-gray-500">Loading tournaments...</li>`;
             try {
                 // Requires index: tournaments: date_created (desc)
                 const q = db.collection('tournaments').orderBy('date_created', 'desc').limit(limit);
                 const snapshot = await q.get();
                 if (snapshot.empty) {
                     listElement.innerHTML = `<li class="text-gray-500">No tournaments created yet.</li>`;
                     return;
                 }
                 listElement.innerHTML = ''; // Clear loading
                 snapshot.forEach(doc => {
                     const tournament = { id: doc.id, ...doc.data() };
                     const li = document.createElement('li');
                     // Different styling for dashboard vs full list
                     li.className = listElementId === 'dashboard-tournaments-list'
                         ? 'border-b pb-2 mb-2 last:border-0 last:pb-0'
                         : 'border p-4 rounded-lg hover:bg-gray-50 transition duration-200';

                     const status = tournament.status || 'Upcoming';
                     const statusColor = status === 'Ongoing' ? 'text-green-600' : (status === 'Completed' ? 'text-gray-500' : 'text-blue-600');
                     const gameType = gameTypesConfig[tournament.game_type] || tournament.game_type || 'N/A'; // Use config
                     const format = tournament.format ? tournament.format.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'N/A'; // Format display
                     const statusBg = status === 'Ongoing' ? 'bg-green-100' : (status === 'Completed' ? 'bg-gray-100' : 'bg-blue-100');

                     // Add data-target attribute for navigation
                     li.innerHTML = `
                         <div class="flex justify-between items-center mb-1">
                            <span class="font-semibold text-lg">${tournament.name || 'Unnamed Tournament'}</span>
                            <span class="${statusColor} font-medium text-xs py-0.5 px-2 rounded-full ${statusBg}">${status}</span>
                         </div>
                         <div class="text-sm text-gray-600 mb-2">
                             <span>Game: ${gameType}</span> | <span>Format: ${format}</span>
                         </div>
                         <a href="#tournament-detail-section" data-tournament-id="${tournament.id}" class="text-blue-600 hover:underline text-sm font-medium view-tournament-details-link">View Details</a>
                     `;
                     listElement.appendChild(li);
                 });
             } catch (error) {
                  console.error(`Error fetching tournaments for ${listElementId}:`, error);
                  if (error.code === 'failed-precondition') {
                     listElement.innerHTML = `<li class="text-red-500">Error: Firestore index missing for tournament date sorting. Check console.</li>`;
                     console.error("Firestore index needed: tournaments collection, date_created (descending).");
                 } else {
                    listElement.innerHTML = `<li class="text-red-500">Error loading tournaments: ${error.message}</li>`;
                 }
             }
        }

        // --- NEW: Tournament Detail View ---
        function openTournamentDetails(tournamentId) {
            console.log(`[TOURNAMENT DETAIL] Opening details for ID: ${tournamentId}`);
            if (!tournamentId) {
                console.error("[TOURNAMENT DETAIL] No tournament ID provided.");
                return;
            }
            showSection('tournament-detail-section'); // Navigate to the detail section
            populateTournamentDetails(tournamentId); // Fetch and display the specific tournament's data
        }

        async function populateTournamentDetails(tournamentId) {
            const container = document.getElementById('tournament-detail-content');
            const loadingEl = document.getElementById('tournament-detail-loading');
            const errorEl = document.getElementById('tournament-detail-error');
            const errorMsgEl = document.getElementById('tournament-detail-error-message');

             if (!container || !loadingEl || !errorEl || !errorMsgEl) { console.error("Tournament detail section elements not found."); return; }
            tournamentDetailSection.classList.add('loading'); tournamentDetailSection.classList.remove('error'); container.style.display = 'none'; // Hide content while loading

        // Inside the function where you add listeners for #edit-tournament-detail-btn etc.
        const addParticipantsButton = container.querySelector('#add-participant-plus-btn'); // <<< CORRECT ID
        if (addParticipantsButton) {
            const listener = () => openAddParticipantsModal(tournamentId); // Pass tournament ID
            addParticipantsButton.addEventListener('click', listener);
            // Optional: Store listener for removal like you do for edit/delete if needed
            // addParticipantsButton._listener = listener;
        }


            // --- Get Element References within Content ---
            const nameEl = container.querySelector('#tournament-detail-name');
            const gameEl = container.querySelector('#tournament-detail-game');
            const formatEl = container.querySelector('#tournament-detail-format');
            const statusEl = container.querySelector('#tournament-detail-status');
            const participantsEl = container.querySelector('#tournament-detail-participants');
            const visualizationEl = container.querySelector('#tournament-detail-visualization');
            const editButton = container.querySelector('#edit-tournament-detail-btn');
            const deleteButton = container.querySelector('#delete-tournament-detail-btn');

            // --- Reset Content ---
            if(nameEl) nameEl.textContent = '[Tournament Name]'; if(gameEl) gameEl.textContent = '[Game]'; if(formatEl) formatEl.textContent = '[Format]'; if(statusEl) statusEl.textContent = '[Status]'; if(participantsEl) participantsEl.innerHTML = '<p class="text-gray-500 italic">Loading participants...</p>'; if(visualizationEl) visualizationEl.innerHTML = 'Visualization Placeholder';

            // --- Remove previous listeners ---
            if (editButton) { let L = editButton._listener; if (L) editButton.removeEventListener('click', L); editButton._listener = null; }
            if (deleteButton) { let L = deleteButton._listener; if (L) deleteButton.removeEventListener('click', L); deleteButton._listener = null; }

            try {
                if (!db) throw new Error("Database not connected");
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                if (!tournamentDoc.exists) { throw new Error("Tournament not found."); }

                const tournamentData = { id: tournamentDoc.id, ...tournamentDoc.data() };
                const gameTypeKey = tournamentData.game_type;
                const gameTypeName = gameTypesConfig[gameTypeKey] || gameTypeKey || 'N/A';

                // --- Populate Details ---
                if(nameEl) nameEl.textContent = tournamentData.name || 'Unnamed Tournament'; if(gameEl) gameEl.textContent = gameTypeName; if(formatEl) formatEl.textContent = tournamentData.format || 'N/A'; if(statusEl) statusEl.textContent = tournamentData.status || 'Upcoming';

                // --- Populate Participants ---
                if (participantsEl && tournamentData.participants && tournamentData.participants.length > 0) {
                    participantsEl.innerHTML = ''; // Clear loading
                    const participantPromises = tournamentData.participants.map(async (pId) => {
                        try { const pDoc = await db.collection('players').doc(pId).get(); if (pDoc.exists) { const pData = pDoc.data(); const pElo = pData.elos?.[gameTypeKey] ?? pData.elo_overall ?? DEFAULT_ELO; return { id: pId, name: pData.name || 'Unnamed', elo: Math.round(pElo) }; } else { return { id: pId, name: 'Unknown', elo: 'N/A' }; } } catch (pErr) { console.error(`Err fetching p ${pId}:`, pErr); return { id: pId, name: 'Error', elo: 'N/A' }; } });
                    const participantsDetails = await Promise.all(participantPromises);
                    participantsDetails.sort((a, b) => (b.elo === 'N/A' ? -Infinity : b.elo) - (a.elo === 'N/A' ? -Infinity : a.elo));
                    participantsDetails.forEach(player => { const div = document.createElement('div'); div.className = 'flex justify-between items-center text-sm border-b border-gray-100 py-1'; div.innerHTML = `<span class="player-link font-medium text-blue-700 hover:underline cursor-pointer" data-player-id="${player.id}">${player.name}</span> <span class="text-gray-600">${player.elo} Elo</span>`; participantsEl.appendChild(div); });
                } else if (participantsEl) { participantsEl.innerHTML = '<p class="text-gray-500 italic">No participants found.</p>'; }

                // --- Visualization Placeholder ---
                if(visualizationEl) visualizationEl.innerHTML = `Visualization for ${tournamentData.format} format coming soon...`;

                // --- Add Event Listeners ---
                if (editButton) { const listener = () => handleEditTournamentDetail(tournamentId); editButton.addEventListener('click', listener); editButton._listener = listener; }
                if (deleteButton) { const listener = () => handleDeleteTournamentDetail(tournamentId); deleteButton.addEventListener('click', listener); deleteButton._listener = listener; }

                // --- Show Content ---
                container.style.display = ''; // Show content div
                tournamentDetailSection.classList.remove('loading'); // Hide loading indicator

            } catch (error) {
                 console.error("Error populating tournament details:", error);
                 if(errorMsgEl) errorMsgEl.textContent = error.message;
                 tournamentDetailSection.classList.remove('loading');
                 tournamentDetailSection.classList.add('error'); // Show error indicator
                 container.style.display = 'none'; // Hide content div on error
            }
        }

// --- NEW: Populate Golf Courses List in Sports Section ---
async function populateGolfCourses() {
    const listElement = document.getElementById('golf-courses-list');
    if (!listElement) {
        console.error("[SPORTS/GOLF] Golf courses list element (#golf-courses-list) not found.");
        return;
    }
    if (!db) {
        console.error("[SPORTS/GOLF] Firestore DB not initialized.");
        listElement.innerHTML = '<p class="text-red-500 p-2">Error: Database connection failed.</p>';
        return;
    }

    console.log("[SPORTS/GOLF] Populating golf courses list...");
    listElement.innerHTML = '<p class="text-gray-500 p-2">Loading courses...</p>'; // Show loading state

    try {
        // Query the 'golf_courses' collection, order by name
        // Requires Firestore index: golf_courses: name (asc)
        const snapshot = await db.collection('golf_courses').orderBy('name').get();

        if (snapshot.empty) {
            listElement.innerHTML = '<p class="text-gray-500 p-2 italic">No golf courses found in the database. Use the "Add New Course" button to add one.</p>';
            return;
        }

        listElement.innerHTML = ''; // Clear loading message

        // Iterate through the courses and create list items
        snapshot.forEach(doc => {
            const course = { id: doc.id, ...doc.data() };
            const courseDiv = document.createElement('div');
            courseDiv.className = 'border-b border-gray-200 pb-3 mb-3 last:border-b-0 last:pb-0 last:mb-0';

            // Basic course display - adapt structure as needed
            courseDiv.innerHTML = `
                <div class="flex justify-between items-center">
                    <h4 class="text-lg font-semibold text-gray-800">${course.name || 'Unnamed Course'}</h4>
                    <span class="text-sm font-medium text-gray-600">Par: ${course.total_par || 'N/A'}</span>
                </div>
                ${course.location ? `<p class="text-xs text-gray-500">${course.location}</p>` : ''}
                `;
            listElement.appendChild(courseDiv);
        });

        console.log(`[SPORTS/GOLF] Populated ${snapshot.size} golf courses.`);

    } catch (error) {
        console.error("[SPORTS/GOLF] Error fetching golf courses:", error);
        if (error.code === 'failed-precondition') {
             listElement.innerHTML = '<p class="text-red-500 p-2">Error: Firestore index missing for sorting courses by name. Please check the console.</p>';
             console.error("Firestore index required: 'golf_courses' collection, 'name' field (ascending). Please create this index in your Firebase console.");
        } else {
            listElement.innerHTML = `<p class="text-red-500 p-2">Error loading courses: ${error.message}</p>`;
        }
    }
}




// --- Add/Edit Tournament Participants Modal Functions ---
async function openAddParticipantsModal(tournamentId) {
            // Get the specific modal container element
            const modalElement = document.getElementById('add-participants-modal');
            if (!modalElement) {
                console.error("Add Participants modal container (#add-participants-modal) not found.");
                alert("Error: Cannot open Add Participants form.");
                return;
            }
            if (!db) {
                console.error("Add Participants modal: DB not ready.");
                alert("Error: Cannot open Add Participants form. Database might not be connected.");
                return;
            }

            console.log(`[MODAL Add Participants] Opening for tournament ${tournamentId}`);
            modalElement.innerHTML = '<div class="modal-content"><p>Loading...</p></div>'; // Basic loading state
            openModal(modalElement); // Open the modal overlay quickly

            let currentParticipants = [];
            let tournamentName = 'Tournament';

            try {
                // 1. Fetch current tournament data (to get existing participants)
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                if (!tournamentDoc.exists) {
                    throw new Error("Tournament data not found.");
                }
                const tournamentData = tournamentDoc.data();
                currentParticipants = tournamentData.participants || [];
                tournamentName = tournamentData.name || tournamentName;

                // 2. Fetch all players (reuse global cache if populated, otherwise fetch)
                if (!playersCachePopulated) {
                    console.warn("[MODAL Add Participants] Player cache not populated, fetching...");
                    await fetchAllPlayersForCache();
                }
                // Convert cache object back to array for easier use here
                const allPlayersArray = Object.values(globalPlayerCache || {});
                if (allPlayersArray.length === 0 && !playersCachePopulated) {
                    // Check again if cache failed
                    throw new Error("Failed to load player list.");
                }

                // 3. Define and Inject the specific HTML content for this modal
                const modalContentHTML = `
                    <div class="modal-content">
                        <button id="close-add-participants-modal-btn" class="modal-close-button">&times;</button>
                        <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Add/Remove Participants</h2>
                        <h3 class="text-lg font-medium mb-4 text-gray-600">${tournamentName}</h3>
                        <form id="add-participants-form" data-tournament-id="${tournamentId}">
                            <div class="mb-5">
                                <label class="block text-gray-700 text-sm font-bold mb-2">Select Players:</label>
                                <div id="add-participants-checklist" class="h-60 border rounded-lg p-3 overflow-y-auto bg-gray-50 space-y-2">
                                    <p class="text-gray-500 p-2">Loading checklist...</p>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">Check players to include them in the tournament.</p>
                            </div>
                            <div class="mt-6 flex justify-end space-x-3">
                                <button type="button" id="cancel-add-participants-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                                <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-5 rounded-lg shadow hover:shadow-md">Update Participants</button>
                            </div>
                        </form>
                    </div>`;
                modalElement.innerHTML = modalContentHTML; // Inject full HTML

                // 4. Populate the checklist
                const participantsChecklistContainer = modalElement.querySelector('#add-participants-checklist');
                if (participantsChecklistContainer) {
                    // Use the helper function to populate, passing current participants
                    populateParticipantChecklist(participantsChecklistContainer, allPlayersArray, currentParticipants);
                } else {
                    console.error("Participant checklist container not found in Add Participants modal.");
                }

                // 5. Attach Event Listeners for elements INSIDE the modal
                const closeButton = modalElement.querySelector('#close-add-participants-modal-btn');
                const cancelButton = modalElement.querySelector('#cancel-add-participants-modal-btn');
                const modalForm = modalElement.querySelector('#add-participants-form');

                if (closeButton) closeButton.addEventListener('click', closeAddParticipantsModal);
                if (cancelButton) cancelButton.addEventListener('click', closeAddParticipantsModal);
                if (modalForm) modalForm.addEventListener('submit', handleAddParticipantsSubmit);

            } catch (error) {
                console.error("[MODAL Add Participants] Error:", error);
                alert(`Error opening participants modal: ${error.message}`);
                // Inject error message into modal and close if necessary
                modalElement.innerHTML = `<div class="modal-content"><p class="text-red-500">Error loading participant data: ${error.message}</p><button id="close-add-participants-error-btn" class="modal-close-button">&times;</button></div>`;
                modalElement.querySelector('#close-add-participants-error-btn')?.addEventListener('click', () => closeModal(modalElement));
                // Don't call openModal again, it's already open
            }
        }

        function closeAddParticipantsModal() {
            const modalElement = document.getElementById('add-participants-modal');
            // Call the generic closeModal function
            closeModal(modalElement);
        }

        async function handleAddParticipantsSubmit(event) {
            event.preventDefault();
            const form = event.target;
            const tournamentId = form.getAttribute('data-tournament-id');
            if (!db || !tournamentId) { alert("Error: DB or Tournament ID missing."); return; }

            const selectedParticipants = []; // Get newly selected participant IDs
            form.querySelectorAll('input[name="participants"]:checked').forEach(checkbox => {
                selectedParticipants.push(checkbox.value);
            });

            // Basic validation (e.g., need at least 2 for non-FFA formats - could fetch format if needed)
            if (selectedParticipants.length < 1) { // Allow 1 participant maybe? Adjust as needed.
                 alert("Please select at least one participant.");
                 return;
            }

            console.log(`[UPDATE PARTICIPANTS] Updating tournament ${tournamentId} with:`, selectedParticipants);

            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                // Update only the participants array and add a timestamp
                await tournamentRef.update({
                    participants: selectedParticipants,
                    last_updated: firebase.firestore.FieldValue.serverTimestamp()
                 });

                alert("Tournament participants updated successfully!");
                closeAddParticipantsModal(); // Close the modal

                // Refresh the tournament details view to show the updated list
                await populateTournamentDetails(tournamentId);

            } catch (error) {
                 console.error("Error updating tournament participants:", error);
                 alert(`Failed to update participants: ${error.message}`);
            }
        }
        // --- End Add/Edit Tournament Participants Modal Functions ---
        // --- Rankings Page Population ---
        async function updateRankingsVisibility() {
            // Ensure necessary elements and DB connection are available
            if (!rankingsGameFilter || !rankingTablesContainer || !db) {
                console.warn("Rankings filter, container, or DB not ready. Cannot update rankings view.");
                // Optionally display an error message in the container
                if(rankingTablesContainer) rankingTablesContainer.innerHTML = '<p class="text-red-500 p-4 text-center">Error initializing rankings view.</p>';
                return;
            }

            const selectedGame = rankingsGameFilter.value; // Get the selected game key ('overall', 'pool', 'golf', etc.)
            console.log(`[RANKING] Filter changed to: ${selectedGame}`);

            // Hide all individual ranking table containers initially
            rankingTablesContainer.querySelectorAll('.ranking-table').forEach(table => {
                table.classList.add('hidden');
                table.classList.remove('active'); // Ensure 'active' class is also removed
            });

            // Construct the ID for the target table container
            const targetTableId = `ranking-table-${selectedGame}`;
            let targetTable = document.getElementById(targetTableId);

            // --- Dynamically create table container if it doesn't exist (for non-'overall' games) ---
            if (!targetTable && selectedGame !== 'overall' && gameTypesConfig[selectedGame]) {
                 console.log(`[RANKING] Dynamically creating table container for ${selectedGame}`);
                 targetTable = document.createElement('div');
                 targetTable.id = targetTableId;
                 // Start hidden, add 'ranking-table' class for easier selection later
                 targetTable.className = 'ranking-table hidden';

                 const gameName = gameTypesConfig[selectedGame]; // Get display name from config

                 // Determine header and title based on whether it's golf
                 const isGolf = selectedGame === 'golf';
                 const ratingHeader = isGolf ? 'Handicap' : 'Rating'; // Use "Handicap" or "Rating"
                 const rankingTypeTitle = isGolf ? 'Handicap Index' : 'Elo'; // For the H2 title

                 // Inject the HTML structure for the table
                 targetTable.innerHTML = `
                     <div class="bg-white p-8 rounded-xl shadow-lg">
                         <h2 class="text-2xl font-semibold mb-5 text-indigo-700">${gameName} Rankings (${rankingTypeTitle})</h2>
                         <table class="w-full text-left table-auto text-base">
                             <thead>
                                 <tr class="bg-gray-100">
                                     <th class="px-4 py-3">Rank</th>
                                     <th class="px-4 py-3">Player</th>
                                     <th class="px-4 py-3">${ratingHeader}</th> 
                                 </tr>
                             </thead>
                             <tbody id="${selectedGame}-rankings-body">
                                
                                 <tr><td colspan="3" class="text-center py-4 text-gray-500">Initializing...</td></tr>
                             </tbody>
                         </table>
                     </div>`;
                 // Append the newly created table container to the main rankings container
                 rankingTablesContainer.appendChild(targetTable);
            }

            // --- Show the selected table and populate its data ---
            if (targetTable) {
                 targetTable.classList.remove('hidden'); // Make the target table visible
                 targetTable.classList.add('active');   // Add active class if needed for styling/selection

                 // Call the appropriate data population function
                 if (selectedGame === 'overall') {
                     // Populate the predefined 'Overall' tables (1v1 Elo, 2v2 placeholder)
                     await populateOverallRankings();
                 } else if (gameTypesConfig[selectedGame]) {
                     // Populate the specific game table (handles golf handicap vs Elo internally)
                     await populateGameRankings(selectedGame);
                 } else {
                     // Handle cases where the selection might be invalid (e.g., somehow selecting an unknown value)
                     console.warn(`Unknown game type selected: ${selectedGame}`);
                     const tbody = targetTable.querySelector('tbody');
                     if (tbody) tbody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-gray-500 italic">Unknown game type selected.</td></tr>`;
                 }
            } else {
                 // If targetTable is still null (e.g., selected 'overall' but its container is missing)
                 console.warn(`Ranking table container for "${selectedGame}" (ID: ${targetTableId}) not found.`);
                 // Optionally display a generic error or fallback
                 rankingTablesContainer.innerHTML = '<p class="text-red-500 p-4 text-center">Error: Could not display selected ranking table.</p>';
            }
        }
        // Populates Overall 1v1 and 2v2 tables
        async function populateOverallRankings() {
             const elo1v1Body = document.getElementById('overall-1v1-rankings-body');
             const elo2v2Body = document.getElementById('overall-2v2-rankings-body');

             // Populate 1v1 Overall Rankings
             if (elo1v1Body && db) {
                 elo1v1Body.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-gray-500">Loading rankings...</td></tr>';
                 try {
                     // Requires index: players: elo_overall (desc)
                     const snapshot = await db.collection('players').orderBy('elo_overall', 'desc').limit(20).get();
                     if (snapshot.empty) {
                        elo1v1Body.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-gray-500">No players found.</td></tr>';
                     } else {
                         elo1v1Body.innerHTML = ''; // Clear loading
                         let rank = 1;
                         snapshot.forEach(doc => {
                             const player = doc.data();
                             const tr = document.createElement('tr');
                             tr.className = 'border-b';
                             tr.innerHTML = `
                                 <td class="px-4 py-2">${rank}</td>
                                 <td class="px-4 py-2">${player.name || 'Unnamed'}</td>
                                 <td class="px-4 py-2">${Math.round(player.elo_overall || DEFAULT_ELO)}</td>
                             `;
                             elo1v1Body.appendChild(tr);
                             rank++;
                         });
                     }
                 } catch (error) {
                      console.error("Error loading Overall 1v1 rankings:", error);
                      if (error.code === 'failed-precondition') {
                         elo1v1Body.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-red-500">Error: Firestore index missing (players: elo_overall desc).</td></tr>';
                         console.error("Firestore index needed: players collection, elo_overall (descending).");
                      } else {
                         elo1v1Body.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-red-500">Error loading rankings.</td></tr>';
                      }
                 }
             }

             // Populate 2v2 Overall Rankings (Placeholder)
             if (elo2v2Body) {
                 elo2v2Body.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-gray-500 italic">2v2 Team rankings not implemented.</td></tr>';
             }
        }

        // Generic function to populate game-specific rankings table
        // Populates game-specific rankings table (Handles Golf Handicap vs Elo)
        // Populates game-specific rankings table (Handles Golf Handicap vs Elo)
        // Populates game-specific rankings table (Handles Golf Handicap vs Elo)
// Populates game-specific rankings table (Handles Golf Handicap vs Elo)
async function populateGameRankings(gameKey) {
             const tableBodyId = `${gameKey}-rankings-body`;
             const tableBody = document.getElementById(tableBodyId);
             const gameName = gameTypesConfig[gameKey] || gameKey;

             if (!tableBody || !db) { /* ... init checks ... */ return; }
             tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-gray-500">Loading ${gameName} rankings...</td></tr>`;

             // --- Conditional Logic: Golf Handicap vs Other Game Elo ---
             if (gameKey === 'golf') {
                 // --- GOLF: Fetch and display by Handicap ---
                 console.log(`[RANKING] Populating Golf Handicap rankings.`);
                 try {
                    // ** Firestore Index Required: players collection, field 'golf_handicap' (Ascending) **
                    const snapshot = await db.collection('players')
                                           .where('golf_handicap', '!=', null) // *** Filter by non-null handicap ***
                                           .orderBy('golf_handicap', 'asc')    // *** Order by handicap ***
                                           .limit(20)
                                           .get();
                     if (snapshot.empty) { /* ... empty message logic ... */
                         const anyPlayer = await db.collection('players').limit(1).get();
                         if (anyPlayer.empty) tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-gray-500">No players found.</td></tr>`;
                         else tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-gray-500">No players have a calculated handicap yet.</td></tr>`;
                     } else {
                        tableBody.innerHTML = ''; let rank = 1;
                        snapshot.forEach(doc => {
                            const player = doc.data();
                            const handicapValue = player.golf_handicap;
                            const displayHandicap = (typeof handicapValue === 'number') ? handicapValue.toFixed(1) : 'N/A';
                            const tr = document.createElement('tr'); tr.className = 'border-b';
                            tr.innerHTML = `<td class="px-4 py-2">${rank}</td><td class="px-4 py-2">${player.name || 'Unnamed'}</td><td class="px-4 py-2">${displayHandicap}</td>`;
                            tableBody.appendChild(tr); rank++;
                        });
                     }
                } catch (error) { /* ... error handling, check for index error ... */
                    console.error(`Error loading Golf Handicap rankings:`, error);
                    if (error.code === 'failed-precondition' || error.message.includes('index')) {
                         tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-red-500">Error: Firestore index missing (players: golf_handicap asc). Check console.</td></tr>`;
                         console.error(`Firestore index needed: players collection, field 'golf_handicap' (ascending).`);
                     } else { tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-red-500">Error loading ${gameName} rankings.</td></tr>`; }
                 }
             } else {
                 // --- OTHER GAMES: Fetch and display by Elo ---
                 console.log(`[RANKING] Populating Elo rankings for ${gameName} (Key: ${gameKey}).`);
                 try {
                    // ** Firestore Index Required: players: elos.<gameKey> (desc) for EACH game type **
                    const fieldPath = `elos.${gameKey}`;
                    const snapshot = await db.collection('players')
                                           .where(fieldPath, '>', 0) // Filter by Elo > 0
                                           .orderBy(fieldPath, 'desc') // Order by Elo descending
                                           .limit(20)
                                           .get();
                    if (snapshot.empty) { /* ... empty message logic ... */
                         const anyPlayer = await db.collection('players').limit(1).get();
                         if (anyPlayer.empty) tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-gray-500">No players found.</td></tr>`;
                         else tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-gray-500">No players have played ${gameName} yet.</td></tr>`;
                    } else {
                        tableBody.innerHTML = ''; let rank = 1;
                        snapshot.forEach(doc => {
                            const player = doc.data();
                            const rating = player.elos?.[gameKey];
                            const tr = document.createElement('tr'); tr.className = 'border-b';
                            tr.innerHTML = `<td class="px-4 py-2">${rank}</td><td class="px-4 py-2">${player.name || 'Unnamed'}</td><td class="px-4 py-2">${rating ? Math.round(rating) : 'N/A'}</td>`;
                            tableBody.appendChild(tr); rank++;
                        });
                     }
                 } catch (error) { /* ... error handling, check for index error ... */
                    console.error(`Error loading ${gameName} Elo rankings:`, error);
                    if (error.code === 'failed-precondition' || error.message.includes('index')) {
                         tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-red-500">Error: Firestore index missing (players: elos.${gameKey} desc). Check console.</td></tr>`;
                         console.error(`Firestore index needed: players collection, field 'elos.${gameKey}' (descending).`);
                     } else { tableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-red-500">Error loading ${gameName} rankings.</td></tr>`; }
                 }
             } // --- End Conditional Logic ---
        }


// --- Event Listeners Setup ---
function setupEventListeners() {
    console.log("[LISTENERS] Setting up...");

    // --- Navigation & General Links ---
    // Handles main nav links AND other links with data-target (like login/register toggles)
    document.querySelectorAll('.nav-link').forEach(link => link.addEventListener('click', handleNavLinkClick));

    // --- Player Login/Register/Logout/Profile ---
    document.getElementById('register-form')?.addEventListener('submit', handlePlayerRegister);
    document.getElementById('player-login-form')?.addEventListener('submit', handlePlayerLogin);
    document.getElementById('google-signin-button')?.addEventListener('click', handleGoogleSignIn);

    // --- New Profile Dropdown Listeners ---
    const profileButton = document.getElementById('profile-photo-button');
    const profileDropdown = document.getElementById('profile-dropdown');
    const editProfileLink = document.getElementById('dropdown-edit-profile');
    const logoutLink = document.getElementById('dropdown-logout');

    // Listener for the profile button to toggle the dropdown
    profileButton?.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent click from bubbling to document
        profileDropdown?.classList.toggle('hidden');
    });

    // Listener for the "Edit Profile" link in the dropdown
    editProfileLink?.addEventListener('click', (event) => {
        event.preventDefault();
        profileDropdown?.classList.add('hidden'); // Hide dropdown
        if (currentPlayer && currentPlayer.id) {
            openPlayerModal(currentPlayer.id); // Open profile modal
        } else {
            console.warn("Edit profile clicked, but no current player ID found.");
            alert("Please log in to edit your profile.");
            showSection('player-login-section');
        }
    });

    // Listener for the "Logout" link in the dropdown
    logoutLink?.addEventListener('click', (event) => {
        event.preventDefault();
        profileDropdown?.classList.add('hidden'); // Hide dropdown
        handlePlayerLogout(); // Call existing player logout function
    });

    // Optional: Close dropdown if clicking anywhere else on the document
    document.addEventListener('click', (event) => {
        // Check if the click target is NOT the profile button AND NOT inside the dropdown
        if (!profileButton?.contains(event.target) && !profileDropdown?.contains(event.target)) {
            profileDropdown?.classList.add('hidden'); // Hide the dropdown
        }
    });
    // --- End New Profile Dropdown Listeners ---


    // --- Admin Contextual Buttons (Modal Triggers - Visibility controlled by CSS/isAdmin flag) ---
    // These buttons likely exist only when an admin is logged in
    openRecordGameModalBtn?.addEventListener('click', openRecordGameModal);
    openAddPlayerModalBtn?.addEventListener('click', openAddPlayerModal);
    openCreateTournamentModalBtn?.addEventListener('click', openCreateTournamentModal);
    openAddGameModalBtn?.addEventListener('click', openAddGameModal);
    // Listener for the admin button to add a new golf course
    document.getElementById('open-add-course-modal-btn')?.addEventListener('click', openAddCourseModal); // Make sure openAddCourseModal exists


    // --- Modal Overlay Click-to-Close (Generic for main modals) ---
    const mainModals = [
        document.getElementById('record-game-modal'), // Also used for edit game
        document.getElementById('player-info-modal'),
        document.getElementById('add-player-modal'),
        document.getElementById('create-tournament-modal'),
        document.getElementById('add-game-modal'),
        document.getElementById('edit-tournament-modal'),
        document.getElementById('add-participants-modal'),
        document.getElementById('add-course-modal'), // Add the new course modal here
        document.getElementById('golf-rules-modal')  // Add the golf rules modal here
    ];
    mainModals.forEach(modal => {
        // Add listener only if the modal element actually exists
        modal?.addEventListener('click', (event) => {
            // Only close if the overlay background itself is clicked, not content inside
            if (event.target === modal) {
                console.log(`[MODAL] Closing modal via overlay click: #${modal.id}`);
                closeModal(modal); // Use the generic close function
            }
        });
    });

    // --- Rankings Filter Dropdown ---
    rankingsGameFilter?.addEventListener('change', updateRankingsVisibility);

    // --- Player Info Modal Buttons (Event Delegation) ---
    // Handles clicks within the Player Info Modal content area
    document.getElementById('player-info-modal')?.querySelector('.modal-content')?.addEventListener('click', (event) => {
        if (event.target.matches('#close-player-modal-btn')) {
            closePlayerModal();
        } else if (event.target.matches('#edit-player-modal-btn')) {
            togglePlayerModalEdit(true);
        } else if (event.target.matches('#save-player-changes-btn')) {
            savePlayerChanges();
        } else if (event.target.matches('#cancel-player-edit-btn')) {
            togglePlayerModalEdit(false);
        } else if (event.target.matches('#delete-player-btn')) {
            deletePlayer();
        }
    });

    // --- Players Grid Click (Event Delegation) ---
    // Handles clicks on player cards in the main player list
    playersGrid?.addEventListener('click', (event) => {
        const playerEntry = event.target.closest('.player-entry');
        if (playerEntry) {
            const playerId = playerEntry.getAttribute('data-player-id');
            if (playerId) {
                console.log(`[Player Grid] Clicked player ID: ${playerId}`);
                openPlayerModal(playerId);
            }
        }
    });

    // --- Results Table Gear Icon Click (Event Delegation for Edit/Delete) ---
    // Handles clicks on the gear icon in the results table (Admin only)
    resultsTableBody?.addEventListener('click', (event) => {
        const targetButton = event.target.closest('.edit-delete-game-btn');
        if (!targetButton) return; // Exit if the click wasn't on the button

        const gameId = targetButton.getAttribute('data-game-id');
        if (!gameId) {
            console.error("Gear button clicked, but no game-id found on the button.");
            return;
        }
        // Assumes visibility is handled by '.admin-only' class
        console.log(`[Results Table] Edit/Delete gear clicked for game: ${gameId}`);
        handleEditGame(gameId); // Function opens the Edit Game Modal
    });


    // --- Body-Level Event Delegation (for dynamically added content like tournament links, player links, sports details) ---
    document.body.addEventListener('click', async (event) => {

        // Ensure event and event.target exist before proceeding
        if (!event || !event.target) {
            // console.warn("Body click listener called without valid event or target."); // Optional log
            return; // Exit if event or target is missing
        }

        // Handle "View Details" links for tournaments
        const tournamentLink = event.target.closest('.view-tournament-details-link');
        if (tournamentLink) {
            event.preventDefault(); // Prevent default link behavior
            const tournamentId = tournamentLink.getAttribute('data-tournament-id');
            if (tournamentId) {
                console.log(`[NAV Delegation] Viewing tournament details for: ${tournamentId}`);
                populateTournamentDetails(tournamentId); // Fetch and display details
            } else {
                console.warn("Clicked view details link without a tournament ID.");
            }
            return; // Stop further processing for this click
        }

        // Handle clicks on player names (e.g., in tournament participant lists)
        const playerLink = event.target.closest('.player-link');
        if (playerLink) {
            event.preventDefault(); // Prevent default if it's an actual <a> tag
            const playerId = playerLink.getAttribute('data-player-id');
            if (playerId) {
                console.log(`[PLAYER LINK Delegation] Clicked for player ID: ${playerId}`);
                openPlayerModal(playerId); // Open the existing player modal
            } else {
                console.warn("Clicked player link without a player ID.");
            }
            return; // Stop further processing for this click
        }

        // Handle "View Details" buttons in the Sports Gallery
        const sportDetailsButton = event.target.closest('.view-sport-details-btn');
        if (sportDetailsButton) {
            event.preventDefault(); // Good practice even for buttons
            const sportKey = sportDetailsButton.getAttribute('data-sport');
            const sportsGallery = document.getElementById('sports-gallery');
            const golfDetailsView = document.getElementById('golf-details-view');

            console.log(`[SPORTS Delegation] Clicked details for sport: ${sportKey}`);

            if (sportKey === 'golf' && sportsGallery && golfDetailsView) {
                // Show Golf Specific View
                sportsGallery.classList.add('hidden');
                golfDetailsView.classList.remove('hidden');
                window.scrollTo(0, 0); // Scroll to top

                // Populate Golf Data when view is shown
                // Ensure these functions exist and handle loading states
                populateGolfCourses();
                // populateGolfResults(); // Add this function if you need to show recent golf results here

            } else if (sportKey === 'overall' || sportKey === 'pool' /* Add other non-golf keys */) {
                // Navigate to the relevant main section (e.g., Rankings)
                console.log(`Navigating to main section for ${sportKey}`);
                showSection('rankings-section'); // Adjust target section as needed
                 // Optionally pre-select the filter if needed
                 if (rankingsGameFilter) {
                     rankingsGameFilter.value = sportKey; // Set filter value
                     await updateRankingsVisibility(); // Update view based on filter
                 }
            } else {
                console.warn(`Unhandled sport key clicked: ${sportKey}`);
            }
            return; // Stop further processing
        }

        // Handle "Back to Sports Gallery" button
        const backToGalleryButton = event.target.closest('#back-to-sports-gallery-btn');
        if (backToGalleryButton) {
            event.preventDefault();
            const sportsGallery = document.getElementById('sports-gallery');
            const golfDetailsView = document.getElementById('golf-details-view');

            if (sportsGallery && golfDetailsView) {
                console.log("[SPORTS Delegation] Clicking back to gallery.");
                golfDetailsView.classList.add('hidden');
                sportsGallery.classList.remove('hidden');
                window.scrollTo(0, 0); // Scroll to top
            }
            return; // Stop further processing
        }

        // Handle "View Official Rules" button (Golf Page)
        const rulesBtn = event.target.closest('#show-golf-rules-btn');
        if (rulesBtn) {
            console.log("[MODAL] Opening golf rules modal.");
            const rulesModal = document.getElementById('golf-rules-modal');
            const rulesIframe = document.getElementById('golf-rules-iframe');
            if (rulesModal && rulesIframe) {
                // Set the iframe src only when opening the modal the first time
                if (rulesIframe.src === 'about:blank') {
                    rulesIframe.src = 'https://www.randa.org/en/rog/the-rules-of-golf'; // Official Rules URL
                }
                openModal(rulesModal); // Use your existing openModal function
            } else {
                console.error("Could not find golf rules modal or iframe elements.");
            }
            return; // Stop further processing
        }

        // Handle closing the Golf Rules modal via its specific close button
        const closeRulesBtn = event.target.closest('#close-golf-rules-modal-btn');
        if (closeRulesBtn) {
            console.log("[MODAL] Closing golf rules modal via button.");
            const rulesModal = document.getElementById('golf-rules-modal');
            if (rulesModal) {
                closeModal(rulesModal); // Use your existing closeModal function
            }
            return; // Stop further processing
        }

        // Add other body-level delegated listeners here if needed...
        // Example: Listener for '+' button in tournament details to add participants
        const addParticipantsButton = event.target.closest('#add-participant-plus-btn');
        if (addParticipantsButton) {
             const tournamentId = addParticipantsButton.getAttribute('data-tournament-id'); // Ensure button has this attribute
             if (tournamentId) {
                 openAddParticipantsModal(tournamentId);
             } else {
                 console.warn("Add participants button clicked without tournament ID.");
             }
             return;
        }


    }); // End of body click listener

    console.log("[LISTENERS] Setup complete.");
} // End of setupEventListeners function

// Handles submission of the Add Player modal form
async function handleAddPlayerSubmit(event) {
            event.preventDefault(); // Prevent default form submission (page reload)
            const form = event.target; // Get the form element that triggered the event
            if (!db) { alert("Database connection error. Cannot add player."); return; }

            // --- Basic Form Validation ---
            let isValid = true;
            form.querySelectorAll('input[required]').forEach(field => {
                field.classList.remove('border-red-500');
                if (!field.value.trim()) { isValid = false; field.classList.add('border-red-500'); }
            });
            if (!isValid) { alert("Please fill out all required fields (Player Name)."); return; }
            // --- End Validation ---

            const formData = new FormData(form);
            const playerName = formData.get('player-name')?.trim();
            const playerIconUrl = formData.get('player-icon-url')?.trim() || null;

            if (!playerName) { console.error("[ADD PLAYER] Player name is empty after trim."); return; }
            console.log(`[ADD PLAYER] Attempting to add player: ${playerName}`);

            try {
                 // --- Initialize Player Data (No Golf Elo) ---
                 const initialElos = { overall: DEFAULT_ELO };
                 ELO_GAME_KEYS.forEach(gameKey => {
                     if (gameKey !== 'golf') { // <-- Exclude 'golf'
                         initialElos[gameKey] = DEFAULT_ELO;
                     }
                 });
                 console.log("[ADD PLAYER] Initial Elos being set:", initialElos);

                 const playerData = {
                     name: playerName,
                     elo_overall: DEFAULT_ELO,
                     elos: initialElos, // Excludes golf elo
                     wins: 0, losses: 0, draws: 0, games_played: 0,
                     golf_handicap: null, // Correctly initialized to null
                     date_created: firebase.firestore.FieldValue.serverTimestamp()
                 };
                 if (playerIconUrl) { playerData.iconUrl = playerIconUrl; }

                 // Add the new player document
                 const docRef = await db.collection('players').add(playerData);
                 console.log(`[FIRESTORE] Player "${playerName}" added successfully with ID: ${docRef.id}`);
                 alert(`Player "${playerName}" added successfully!`);
                 closeAddPlayerModal();
                 if (playersGrid) await populatePlayersList();

            } catch (error) { console.error("Error adding player:", error); alert(`Failed to add player: ${error.message}`); }
        }
        // Handles submission of the Create Tournament modal form
        async function handleCreateTournamentSubmit(event) {
            event.preventDefault();
            const form = event.target;
            if (!db) { alert("Database connection error."); return; }

            // Basic validation
            let isValid = true;
            form.querySelectorAll('input[required], select[required]').forEach(field => {
                field.classList.remove('border-red-500');
                if (!field.value) { isValid = false; field.classList.add('border-red-500'); }
            });
            if (!isValid) { alert("Please fill out all required fields."); return; }

            const formData = new FormData(form);
            const selectedParticipants = []; // Get selected participant IDs
            form.querySelectorAll('input[name="participants"]:checked').forEach(checkbox => {
                selectedParticipants.push(checkbox.value);
            });

            const format = formData.get('tournament-format');
            // Validate participant count based on format (example)
            if (format !== 'ffa' && selectedParticipants.length < 2) {
                 alert("Please select at least two participants for this format.");
                 return;
            }
             // More validation could be added (e.g., power of 2 for single/double elim)

             // Data for the new tournament document
             const tournamentData = {
                 name: formData.get('tournament-name')?.trim(),
                 game_type: formData.get('tournament-game-type'),
                 format: format,
                 start_date: formData.get('tournament-start-date') || null, // Store date or null
                 participants: selectedParticipants, // Array of player IDs
                 status: 'Upcoming', // Initial status
                 date_created: firebase.firestore.FieldValue.serverTimestamp(),
                 // Could add structure for bracket/matches later
             };

             if (!tournamentData.name || !tournamentData.game_type || !tournamentData.format) return; // Should be caught by validation

             try {
                 // Add the new tournament document to Firestore
                 await db.collection('tournaments').add(tournamentData);
                 alert(`Tournament "${tournamentData.name}" created successfully!`);
                 closeCreateTournamentModal(); // Close the modal
                 // Refresh tournament lists
                 await populateTournamentsList('dashboard-tournaments-list', 3);
                 await populateTournamentsList('tournaments-list-full');
             } catch (error) {
                 console.error("Error creating tournament:", error);
                 alert(`Failed to create tournament: ${error.message}`);
             }
        }


        // Handles submission of the Record Game modal form
        // Handles submission of the Record Game modal form (Modified for Golf)
        // Handles submission of the Record Game modal form (Modified for Detailed Golf Entry)
        // Handles submission of the Record Game modal form (Modified for Detailed Golf Entry & Debugging)
        async function handleRecordGameSubmit(event) {
             event.preventDefault();
             const form = event.target;
             console.log("[SUBMIT] Record Game form submitted."); // Log: Start
             if (!db) { alert("Database connection error."); return; }

             const gameTypeSelect = form.querySelector('#game-type-select-modal');
             const gameType = gameTypeSelect?.value;

             if (!gameType) {
                 alert("Please select a game type.");
                 if (gameTypeSelect) gameTypeSelect.classList.add('border-red-500');
                 console.log("[SUBMIT] Validation failed: No game type selected."); // Log: Fail
                 return;
             }
             if (gameTypeSelect) gameTypeSelect.classList.remove('border-red-500');


             // --- Handle Golf Separately ---
             if (gameType === 'golf') {
                console.log("[SUBMIT] Handling Golf submission."); // Log: Golf Path
                // ... (Keep all the golf-specific variable declarations) ...
                const golfPlayerSelect = form.querySelector('#golf_player');
                const golfCourseSelect = form.querySelector('#golf_course');
                const scoreInput = form.querySelector('#score');
                const golfHolesRadios = form.querySelectorAll('input[name="golf-holes-played"]');
                const golfTrackCheckbox = form.querySelector('#golf-track-holes');
                const golfHoleInputsContainer = form.querySelector('#golf-hole-inputs-container');
                const playerId = golfPlayerSelect?.value;
                const courseId = golfCourseSelect?.value;
                const holesPlayed = Array.from(golfHolesRadios).find(radio => radio.checked)?.value || '18';
                const trackScores = golfTrackCheckbox?.checked || false;
                let score = NaN;
                let holeScoresData = null;
                let isGolfValid = true; // Start validation flag

                 // --- Golf Validation ---
                 console.log("[SUBMIT Golf] Starting validation..."); // Log: Golf Validation Start
                 // ... (Keep all the detailed golf validation logic) ...
                 if (!playerId) { /* ... */ isGolfValid = false; } else { /* ... */ }
                 if (!courseId) { /* ... */ isGolfValid = false; } else { /* ... */ }
                 if (trackScores) { /* ... (Validate hole scores, calculate total, set isGolfValid flag) ... */
                    holeScoresData = {};
                    let calculatedTotal = 0;
                    let firstInvalidHoleInput = null;
                    const holeInputs = golfHoleInputsContainer?.querySelectorAll('.hole-score-input');
                    if (!holeInputs || holeInputs.length === 0) { alert("Error: Could not find hole score inputs."); isGolfValid = false; }
                    else { /* ... loop through inputs, validate, sum, set isGolfValid ... */
                        holeInputs.forEach(input => { /* ... validation logic ... */ });
                        if(isGolfValid) { score = calculatedTotal; if(scoreInput) scoreInput.value = score; }
                        else { if(firstInvalidHoleInput) firstInvalidHoleInput.focus(); }
                    }
                 } else { /* ... (Validate total score, set isGolfValid flag) ... */
                    if (!scoreInput || !scoreInput.value) { /* ... */ isGolfValid = false; }
                    else { score = parseInt(scoreInput.value, 10); if (isNaN(score) || score <= 0) { /* ... */ isGolfValid = false; } else { /* ... */ } }
                 }

                 if (!isGolfValid) { console.log("[SUBMIT Golf] Validation failed."); return; } // Log: Golf Fail
                 console.log("[SUBMIT Golf] Validation passed."); // Log: Golf Pass
                 // --- End Golf Validation ---

                 // Prepare Golf Game Data
                 const golfGameData = { /* ... (keep data preparation) ... */
                    game_type: 'golf', date_played: firebase.firestore.FieldValue.serverTimestamp(),
                    player_id: playerId, score: score, course_id: courseId === 'none' ? null : courseId,
                    outcome: 'Completed', participants: [playerId], holes_played: holesPlayed, hole_scores: holeScoresData
                 };
                 console.log("[SUBMIT Golf] Golf Data to save:", golfGameData);

                 try {
                     console.log("[SUBMIT Golf] Attempting Firestore save..."); // Log: Golf Save Start
                     const docRef = await db.collection('games').add(golfGameData);
                     console.log("[SUBMIT Golf] Firestore save successful, ID:", docRef.id); // Log: Golf Save Success
                     const playerRef = db.collection('players').doc(playerId);
                     await playerRef.update({ games_played: firebase.firestore.FieldValue.increment(1) });
                     console.log(`[SUBMIT Golf] Updated stats for player ${playerId}.`); // Log: Golf Stat Update
                     await updateGolfHandicap(playerId); // Call handicap update

                     alert("Golf score recorded successfully!"); // Success Alert

                     console.log("[SUBMIT Golf] Calling closeRecordGameModal..."); // Log: Before Close
                     closeRecordGameModal();
                     console.log("[SUBMIT Golf] Called closeRecordGameModal. Refreshing UI..."); // Log: After Close

                     await populateResultsTable();
                     await populateDashboard();
                     console.log("[SUBMIT Golf] UI Refresh complete."); // Log: Golf UI Refresh Done

                 } catch (error) {
                     console.error("[SUBMIT Golf] Error saving data:", error); // Log: Golf Error
                     alert(`Error saving golf score: ${error.message}`);
                 }
                 return;
             }
             // --- End Golf Handling ---


             // --- Existing Non-Golf Game Logic ---
             console.log("[SUBMIT] Handling Non-Golf submission."); // Log: Non-Golf Path
             // ... (Keep non-golf validation logic) ...
             let isNonGolfValid = true;
             const winnerSelect = form.querySelector('#winner_player');
             const loserSelect = form.querySelector('#loser_player');
             const winnerId = winnerSelect?.value; const loserId = loserSelect?.value;
             const isDraw = form.querySelector('#is_draw')?.checked; const scoreInput = form.querySelector('#score');
             if (!winnerSelect || !loserSelect) { console.error("Winner/Loser selects not found."); return; }
             winnerSelect.classList.remove('border-red-500'); loserSelect.classList.remove('border-red-500');
             if (!winnerId) { winnerSelect.classList.add('border-red-500'); isNonGolfValid = false; }
             if (!loserId) { loserSelect.classList.add('border-red-500'); isNonGolfValid = false; }
             if (winnerId && loserId && !isDraw && winnerId === loserId) { /* ... */ isNonGolfValid = false; }
             if (!isNonGolfValid) { console.log("[SUBMIT Non-Golf] Validation failed."); alert("Please select valid players."); return; } // Log: Non-Golf Fail
             console.log("[SUBMIT Non-Golf] Validation passed."); // Log: Non-Golf Pass

             // Prepare NON-GOLF game data
             const nonGolfGameData = { /* ... (keep data structure) ... */
                game_type: gameType, date_played: firebase.firestore.FieldValue.serverTimestamp(),
                score: scoreInput?.value.trim() || null, outcome: isDraw ? 'Draw' : 'Win/Loss',
                participants: isDraw ? [winnerId, loserId].sort() : [winnerId, loserId],
             };
             console.log("[SUBMIT Non-Golf] Data to save:", nonGolfGameData);

             try {
                 console.log("[SUBMIT Non-Golf] Calculating Elo/Stats..."); // Log: Elo Calc Start
                 // Elo Calculation & Stat Updates
                 let eloUpdates = {}; const FieldValue = firebase.firestore.FieldValue;
                 const player1StatUpdates = { games_played: FieldValue.increment(1) }; const player2StatUpdates = { games_played: FieldValue.increment(1) };
                 if (ELO_GAME_KEYS.includes(gameType)) { /* ... (Elo calc logic) ... */
                    if (!isDraw) { /* ... */ } else { /* ... */ }
                 } else { /* ... (Non-Elo stat logic) ... */ }
                 const finalUpdates = {}; /* ... (Combine updates logic) ... */
                 const p1Id = winnerId; const p2Id = loserId;
                 if (p1Id && (eloUpdates[p1Id] || Object.keys(player1StatUpdates).length > 0)) { finalUpdates[p1Id] = { ...(eloUpdates[p1Id] || {}), ...player1StatUpdates }; }
                 if (p2Id && (eloUpdates[p2Id] || Object.keys(player2StatUpdates).length > 0)) { finalUpdates[p2Id] = { ...(eloUpdates[p2Id] || {}), ...player2StatUpdates }; }
                 console.log("[SUBMIT Non-Golf] Combined Elo/Stat Updates:", finalUpdates);

                 // Save game and update players
                 console.log("[SUBMIT Non-Golf] Attempting Firestore save..."); // Log: Non-Golf Save Start
                 const docRef = await db.collection('games').add(nonGolfGameData);
                 console.log("[SUBMIT Non-Golf] Game save successful, ID:", docRef.id); // Log: Non-Golf Game Save Success
                 if (Object.keys(finalUpdates).length > 0) {
                    await updatePlayerElosAndStats(finalUpdates);
                    console.log("[SUBMIT Non-Golf] Player Elo/Stat update successful."); // Log: Non-Golf Player Update Success
                 }

                 alert("Game result recorded successfully!"); // Success Alert

                 console.log("[SUBMIT Non-Golf] Calling closeRecordGameModal..."); // Log: Before Close
                 closeRecordGameModal();
                 console.log("[SUBMIT Non-Golf] Called closeRecordGameModal. Refreshing UI..."); // Log: After Close

                 await populateResultsTable();
                 await populateDashboard();
                 if (document.getElementById('rankings-section') && !document.getElementById('rankings-section').classList.contains('hidden')) { await updateRankingsVisibility(); }
                 console.log("[SUBMIT Non-Golf] UI Refresh complete."); // Log: Non-Golf UI Refresh Done

             } catch (error) {
                 console.error("[SUBMIT Non-Golf] Error saving data:", error); // Log: Non-Golf Error
                 alert(`Error saving game result: ${error.message}`);
             }
        }

        // Handles submission of the Add New Game Type modal form
        async function handleAddGameSubmit(event) {
            event.preventDefault();
            const form = event.target;
            if (!db) { alert("Database connection error."); return; }

            const formData = new FormData(form);
            const gameKey = formData.get('new-game-key')?.trim().toLowerCase();
            const gameName = formData.get('new-game-name')?.trim();

            // --- Validation ---
            if (!gameKey || !gameName) {
                alert("Please enter both a Game Key and a Display Name.");
                return;
            }
            // Basic validation for key format (lowercase, numbers, underscores)
            if (!/^[a-z0-9_]+$/.test(gameKey)) {
                alert("Game Key can only contain lowercase letters, numbers, and underscores.");
                form.querySelector('#new-game-key').classList.add('border-red-500');
                return;
            }
            // Check if game key already exists in local config
            if (gameTypesConfig[gameKey]) {
                alert(`Game Key "${gameKey}" already exists.`);
                form.querySelector('#new-game-key').classList.add('border-red-500');
                return;
            }
            // --- End Validation ---

            console.log(`[ADD GAME] Attempting to add: Key=${gameKey}, Name=${gameName}`);

            // 1. Update local config immediately (for UI responsiveness)
            gameTypesConfig[gameKey] = gameName;
            ELO_GAME_KEYS = Object.keys(gameTypesConfig); // Update the keys list used for Elo checks
            console.log("[ADD GAME] Updated local gameTypesConfig:", gameTypesConfig);

            // 2. Update UI Elements (Dropdowns, Ranking Filter)
            updateGameTypeDropdowns();
            // Note: Dynamically adding the ranking table itself is handled in updateRankingsVisibility

            // 3. Update existing players in Firestore to include the new game type with default Elo
            // This can be slow/costly on large datasets. Consider alternatives for production.
            alert("Updating existing players with new game rating... This might take a moment.");
            try {
                const playersRef = db.collection('players');
                const snapshot = await playersRef.get();
                const batch = db.batch(); // Use a batch write for efficiency
                let operationCount = 0;

                if (snapshot.empty) {
                    console.log("[ADD GAME] No existing players found to update.");
                } else {
                    console.log(`[ADD GAME] Found ${snapshot.size} players to update.`);
                    snapshot.forEach(doc => {
                        const playerRef = playersRef.doc(doc.id);
                        const updateData = {};
                        // Use dot notation to update the nested 'elos' map
                        updateData[`elos.${gameKey}`] = DEFAULT_ELO;
                        batch.update(playerRef, updateData);
                        operationCount++;

                        // Firestore batch limit is 500 operations. Commit and start new batch if needed.
                        // This simple batching might still timeout on very large datasets.
                        // Consider Cloud Functions for large-scale updates.
                        if (operationCount >= 499) { // Leave a little buffer
                             console.warn("[ADD GAME] Batch limit reached, committing partial batch...");
                             batch.commit().then(() => console.log("[ADD GAME] Partial batch committed.")); // Commit current batch
                             batch = db.batch(); // Start a new batch
                             operationCount = 0;
                        }
                    });

                    // Commit any remaining operations in the last batch
                    if (operationCount > 0) {
                         await batch.commit();
                         console.log("[ADD GAME] Final player update batch committed.");
                    }
                }

                alert(`Game "${gameName}" added successfully! Existing players updated.`);
                closeAddGameModal(); // Close the modal
                // Refresh rankings view if currently visible to show the new option/table
                if (rankingsGameFilter) updateRankingsVisibility();

            } catch (error) {
                console.error("Error updating existing players with new game:", error);
                alert(`Failed to update existing players: ${error.message}. The game type was added locally but may not be reflected for existing players.`);
                // Optionally revert local config change if Firestore update fails:
                // delete gameTypesConfig[gameKey];
                // ELO_GAME_KEYS = Object.keys(gameTypesConfig);
                // updateGameTypeDropdowns();
            }
        }
// --- Helper: Get Course Par by ID (with Caching) ---
        // Pass a cache object specific to the calling function's context
// --- Helper: Get Course Par by ID (with Caching) ---
async function getCourseParById(courseId, cacheObject) {
            if (!courseId) return null;
            if (cacheObject[courseId] !== undefined) return cacheObject[courseId];
            try {
                if (!db) { console.warn("DB not ready for getCourseParById"); return null; }
                const courseDoc = await db.collection('golf_courses').doc(courseId).get();
                let par = null;
                if (courseDoc.exists) {
                    const data = courseDoc.data();
                    if (typeof data.total_par === 'number') {
                        par = data.total_par;
                    } else { console.warn(`[getCourseParById] Course ${courseId} invalid 'total_par'.`); }
                } else { console.warn(`[getCourseParById] Course doc ${courseId} not found.`); }
                cacheObject[courseId] = par; return par;
            } catch (err) {
                console.error(`[getCourseParById] Error fetching course ${courseId}:`, err);
                cacheObject[courseId] = null; return null;
            }
        }

       // --- Golf Handicap Calculation (Simplified: Average Differential of Last 10 - Fixed Query) ---
       // --- Golf Handicap Calculation (Debug Firestore Update) ---
       // --- Helper: Get Course Par by ID (with Caching) ---
        // (Make sure this function is defined - provided in previous response)
        async function getCourseParById(courseId, cacheObject) {
            // ... (full function code) ...
            if (!courseId) return null; if (cacheObject[courseId] !== undefined) return cacheObject[courseId];
            try { if (!db) { return null; } const courseDoc = await db.collection('golf_courses').doc(courseId).get(); let par = null; if (courseDoc.exists) { const data = courseDoc.data(); if (typeof data.total_par === 'number') { par = data.total_par; } } cacheObject[courseId] = par; return par; } catch (err) { console.error(`[getCourseParById] Error fetching course ${courseId}:`, err); cacheObject[courseId] = null; return null; }
        }

        // --- Golf Handicap Calculation (Simplified: Average Differential of Last 10 - Debugging Update) ---
        // --- Golf Handicap Calculation (Simplified: Average Differential of Last 10 - Debugging Update) ---
// --- Golf Handicap Calculation (Simplified: Average Differential of Last 10 - Fixed Query) ---
async function updateGolfHandicap(playerId, scoresToConsider = 10) {
            if (!db || !playerId) { console.warn("[HANDICAP CALC] DB or Player ID missing."); return; }
            console.log(`[HANDICAP DEBUG] === Starting calculation for player ${playerId} (Scores: ${scoresToConsider}) ===`);
            const handicapCalcCache = {};

            try {
                // Step 1: Fetch scores
                console.log(`[HANDICAP DEBUG] Fetching last ${scoresToConsider} golf scores...`);
                // *** Firestore Index Required: games: player_id (Asc), game_type (Asc), date_played (Desc) ***
                const gamesSnapshot = await db.collection('games')
                    .where('player_id', '==', playerId)
                    .where('game_type', '==', 'golf')
                    .orderBy('date_played', 'desc') // *** THIS QUERY NEEDS THE COMPOSITE INDEX ***
                    .limit(scoresToConsider)
                    .get();

                if (gamesSnapshot.empty) { console.log(`[HANDICAP DEBUG] No golf scores found. Exiting calculation.`); return; }
                console.log(`[HANDICAP DEBUG] Found ${gamesSnapshot.size} potential scores.`);

                // Step 3: Calculate differentials
                const differentials = [];
                console.log(`[HANDICAP DEBUG] Calculating differentials...`);
                for (const gameDoc of gamesSnapshot.docs) {
                    const gameData = gameDoc.data();
                    const score = gameData.score; const courseId = gameData.course_id; const holesPlayed = gameData.holes_played || '18';
                    // *** Check for courseId BEFORE using it ***
                    if (!courseId) { console.log(`[HANDICAP DEBUG] Skipping game ${gameDoc.id}: Missing course_id.`); continue; }
                    if (typeof score !== 'number') { console.log(`[HANDICAP DEBUG] Skipping game ${gameDoc.id}: Invalid score.`); continue; }
                    const coursePar = await getCourseParById(courseId, handicapCalcCache);
                    if (typeof coursePar !== 'number') { console.log(`[HANDICAP DEBUG] Skipping game ${gameDoc.id}: Invalid par for course ${courseId}.`); continue; }
                    let parForRound = coursePar;
                    if (holesPlayed === '9F' || holesPlayed === '9B') { parForRound = Math.round(coursePar / 2); }
                    const differential = score - parForRound;
                    differentials.push(differential);
                    console.log(`[HANDICAP DEBUG] Game ${gameDoc.id}: Score=${score}, Par=${parForRound}, Diff=${differential}`);
                }

                // Step 4: Calculate average
                if (differentials.length === 0) { console.log(`[HANDICAP DEBUG] No valid differentials. Exiting.`); return; }
                const sumOfDifferentials = differentials.reduce((sum, diff) => sum + diff, 0);
                const calculatedHandicap = sumOfDifferentials / differentials.length;
                const finalHandicap = Math.round(calculatedHandicap * 10) / 10;
                console.log(`[HANDICAP DEBUG] Final Handicap Calculated: ${finalHandicap} (Type: ${typeof finalHandicap}) from ${differentials.length} diffs`);

                // Step 5: Update Firestore
                const playerRef = db.collection('players').doc(playerId);
                if (typeof finalHandicap === 'number' && !isNaN(finalHandicap)) {
                    console.log(`[HANDICAP DEBUG] Preparing Firestore update for player ${playerId}: { golf_handicap: ${finalHandicap} }`);
                    try {
                        await playerRef.update({ golf_handicap: finalHandicap });
                        console.log(`[HANDICAP DEBUG] Firestore update successful for player ${playerId}.`);
                    } catch (updateError) {
                        console.error(`[HANDICAP DEBUG] Firestore update FAILED for player ${playerId}:`, updateError);
                        alert(`Failed to save calculated handicap: ${updateError.message}`); return;
                    }
                } else {
                    console.error(`[HANDICAP DEBUG] Calculated finalHandicap (${finalHandicap}) is not valid. Skipping update.`);
                    alert("Error: Calculated handicap was not valid."); return;
                }

                // Optional: Refresh rankings
                if (rankingsGameFilter?.value === 'golf' && document.getElementById('rankings-section') && !document.getElementById('rankings-section').classList.contains('hidden')) {
                     console.log("[HANDICAP DEBUG] Refreshing golf rankings display.");
                     await populateGameRankings('golf');
                }
                 console.log(`[HANDICAP DEBUG] === Calculation finished successfully for player ${playerId} ===`);

            } catch (error) {
                 console.error(`[HANDICAP DEBUG] === Error during calculation process for player ${playerId}:`, error);
                 // Specific check for index error from the main query
                 if (error.code === 'failed-precondition' || error.message.includes('index')) {
                     console.error("Firestore index likely needed for the handicap query: games collection, fields: player_id (==), game_type (==), date_played (desc). Please create this index in your Firebase console.");
                     alert("Error calculating handicap: A database index is missing. Please check the console and create the required index.");
                 } else { alert(`An error occurred while calculating the handicap: ${error.message}`); }
            }
        }
        
        
        
        // --- Elo Calculation & Update Functions ---

        // Calculates Elo change for a Win/Loss result
        async function calculateEloUpdate(winnerId, loserId, gameType) {
            if (!db || !winnerId || !loserId || !gameType) { console.error("[ELO Calc] Missing required parameters or DB connection."); return {}; }
            console.log(`[ELO Calc] Calculating update for ${gameType}: Winner=${winnerId}, Loser=${loserId}`);
            try {
                // Fetch both players' data concurrently
                const winnerRef = db.collection('players').doc(winnerId);
                const loserRef = db.collection('players').doc(loserId);
                const [winnerDoc, loserDoc] = await Promise.all([winnerRef.get(), loserRef.get()]);

                if (!winnerDoc.exists || !loserDoc.exists) {
                    console.error("[ELO Calc] Winner or loser document not found.");
                    alert("Error: Could not find player data for Elo calculation.");
                    return {}; // Return empty object on error
                }

                const winnerData = winnerDoc.data();
                const loserData = loserDoc.data();

                // Get current Elo for the specific game type, defaulting to DEFAULT_ELO if not present
                const winnerElo = winnerData.elos?.[gameType] || DEFAULT_ELO;
                const loserElo = loserData.elos?.[gameType] || DEFAULT_ELO;
                console.log(`[ELO Calc] Current ${gameType} Elo: Winner=${winnerElo}, Loser=${loserElo}`);

                // Standard Elo calculation formulas
                const exponent = (loserElo - winnerElo) / 400;
                const expectedScoreWinner = 1 / (1 + Math.pow(10, exponent));
                // const expectedScoreLoser = 1 - expectedScoreWinner; // Not strictly needed for update calculation

                // Calculate new Elo ratings, rounding to nearest integer
                const newWinnerElo = Math.round(winnerElo + K_FACTOR * (1 - expectedScoreWinner)); // Winner's actual score is 1
                const newLoserElo = Math.round(loserElo + K_FACTOR * (0 - (1 - expectedScoreWinner))); // Loser's actual score is 0

                console.log(`[ELO Calc] New ${gameType} Elo: Winner=${newWinnerElo}, Loser=${newLoserElo}`);

                // Prepare update objects using dot notation for nested fields
                const winnerUpdates = {}; winnerUpdates[`elos.${gameType}`] = newWinnerElo;
                const loserUpdates = {}; loserUpdates[`elos.${gameType}`] = newLoserElo;

                // Return updates keyed by player ID
                return { [winnerId]: winnerUpdates, [loserId]: loserUpdates };

            } catch (error) {
                console.error("[ELO Calc] Error calculating Elo update:", error);
                alert(`Error calculating Elo: ${error.message}`);
                return {}; // Return empty object on error
            }
        }

        // Calculates Elo change for a Draw result
        async function calculateEloUpdateDraw(player1Id, player2Id, gameType) {
             if (!db || !player1Id || !player2Id || !gameType) { console.error("[ELO Calc Draw] Missing required parameters or DB connection."); return {}; }
             console.log(`[ELO Calc Draw] Calculating update for ${gameType} Draw: P1=${player1Id}, P2=${player2Id}`);
             try {
                // Fetch both players' data concurrently
                const p1Ref = db.collection('players').doc(player1Id);
                const p2Ref = db.collection('players').doc(player2Id);
                const [p1Doc, p2Doc] = await Promise.all([p1Ref.get(), p2Ref.get()]);

                if (!p1Doc.exists || !p2Doc.exists) {
                    console.error("[ELO Calc Draw] Player document not found.");
                    alert("Error: Could not find player data for Elo calculation.");
                    return {};
                }

                const p1Data = p1Doc.data();
                const p2Data = p2Doc.data();

                // Get current Elo for the specific game type
                const p1Elo = p1Data.elos?.[gameType] || DEFAULT_ELO;
                const p2Elo = p2Data.elos?.[gameType] || DEFAULT_ELO;
                console.log(`[ELO Calc Draw] Current ${gameType} Elo: P1=${p1Elo}, P2=${p2Elo}`);

                // Elo calculation for draw (actual score is 0.5 for both)
                const exponent1 = (p2Elo - p1Elo) / 400;
                const expectedScoreP1 = 1 / (1 + Math.pow(10, exponent1));
                const expectedScoreP2 = 1 - expectedScoreP1; // Or calculate symmetrically

                const newP1Elo = Math.round(p1Elo + K_FACTOR * (0.5 - expectedScoreP1));
                const newP2Elo = Math.round(p2Elo + K_FACTOR * (0.5 - expectedScoreP2));

                console.log(`[ELO Calc Draw] New ${gameType} Elo: P1=${newP1Elo}, P2=${newP2Elo}`);

                // Prepare update objects
                const p1Updates = {}; p1Updates[`elos.${gameType}`] = newP1Elo;
                const p2Updates = {}; p2Updates[`elos.${gameType}`] = newP2Elo;

                // Return updates keyed by player ID
                return { [player1Id]: p1Updates, [player2Id]: p2Updates };

             } catch (error) {
                 console.error("[ELO Calc Draw] Error calculating Elo update:", error);
                 alert(`Error calculating Elo for draw: ${error.message}`);
                 return {};
             }
        }


               // --- Tournament Edit Modal Functions (Refactored for Generic Modal) ---
       let currentTournamentData = null; // Store data for edit modal



function openEditTournamentModal(tournamentData) {
    // Get the specific modal container element
    const modalElement = document.getElementById('edit-tournament-modal');
    if (!modalElement) {
        console.error("Edit Tournament modal container (#edit-tournament-modal) not found.");
        alert("Error: Cannot open Edit Tournament form.");
        return;
    }
    // Note: DB check isn't strictly needed to open, but submit handler requires it.

    currentTournamentData = tournamentData; // Store data for reference

    // Format date if it exists
    let startDateStr = '';
    // Check if start_date exists and is a Firestore Timestamp before calling .toDate()
    if (tournamentData.start_date && typeof tournamentData.start_date.toDate === 'function') {
        try {
            const dateObj = tournamentData.start_date.toDate();
            const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
            const day = dateObj.getDate().toString().padStart(2, '0');
            startDateStr = `${dateObj.getFullYear()}-${month}-${day}`;
        } catch (e) { console.warn("Error formatting start date for input:", e); }
    } else if (tournamentData.start_date && typeof tournamentData.start_date === 'string') {
        // Handle case where date might already be a string (e.g., if re-opening without fresh fetch)
        startDateStr = tournamentData.start_date.split('T')[0]; // Basic handling for ISO string
    }

    // Define and Inject the specific HTML content for this modal
    const modalContentHTML = `
        <div class="modal-content">
            <button id="close-edit-tournament-modal-btn" class="modal-close-button">&times;</button>
            <h2 class="text-2xl font-semibold mb-5 text-indigo-700">Edit Tournament (ID: ${tournamentData.id})</h2>
            <form id="edit-tournament-form" data-tournament-id="${tournamentData.id}">
                 <div class="mb-4">
                     <label for="edit-tournament-name" class="block text-gray-700 text-sm font-bold mb-2">Tournament Name:</label>
                     <input type="text" id="edit-tournament-name" name="tournament-name" value="${tournamentData.name || ''}" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700" required>
                 </div>
                 <div class="mb-4">
                     <label for="edit-tournament-game-type" class="block text-gray-700 text-sm font-bold mb-2">Game Type:</label>
                     <select id="edit-tournament-game-type" name="tournament-game-type" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700 bg-gray-100" disabled>
                         <option value="">Loading...</option>
                         
                     </select>
                     <p class="text-xs text-gray-500 mt-1">Game type cannot be changed after creation.</p>
                 </div>
                 <div class="mb-4">
                     <label for="edit-tournament-format" class="block text-gray-700 text-sm font-bold mb-2">Format:</label>
                     <select id="edit-tournament-format" name="tournament-format" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                         <option value="">Select Format</option>
                         <option value="single-elim">Single Elimination</option>
                         <option value="double-elim">Double Elimination</option>
                         <option value="round-robin">Round Robin</option>
                     </select>
                 </div>
                 <div class="mb-4">
                     <label for="edit-tournament-start-date" class="block text-gray-700 text-sm font-bold mb-2">Start Date (Optional):</label>
                     <input type="date" id="edit-tournament-start-date" name="tournament-start-date" value="${startDateStr}" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700">
                 </div>
                 <div class="mb-4">
                     <label for="edit-tournament-status" class="block text-gray-700 text-sm font-bold mb-2">Status:</label>
                     <select id="edit-tournament-status" name="tournament-status" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700" required>
                         <option value="Upcoming">Upcoming</option>
                         <option value="Ongoing">Ongoing</option>
                         <option value="Completed">Completed</option>
                     </select>
                 </div>
                 

                 <div class="mt-6 flex justify-between items-center"> 
                     
                     <button type="button" id="modal-add-participants-btn" title="Add/Remove Participants" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg shadow hover:shadow-md text-lg leading-tight">
                         + Participants
                     </button>

                     
                     <div class="space-x-3">
                        <button type="button" id="cancel-edit-tournament-modal-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg">Cancel</button>
                        <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-5 rounded-lg shadow hover:shadow-md">Save Changes</button>
                    </div>
                 </div>
             </form>
        </div>`;

    modalElement.innerHTML = modalContentHTML; // Inject HTML

    // Get references and Populate dropdowns and set initial values
    const gameTypeSelect = modalElement.querySelector('#edit-tournament-game-type');
    const formatSelect = modalElement.querySelector('#edit-tournament-format');
    const statusSelect = modalElement.querySelector('#edit-tournament-status');

    if(gameTypeSelect) {
         populateSelectWithOptions(gameTypeSelect, gameTypesConfig, 'Select Type');
         gameTypeSelect.value = tournamentData.game_type || '';
    }
    if(formatSelect) formatSelect.value = tournamentData.format || '';
    if(statusSelect) statusSelect.value = tournamentData.status || 'Upcoming';

    // Attach listeners for elements INSIDE the modal
    const closeButton = modalElement.querySelector('#close-edit-tournament-modal-btn');
    const cancelButton = modalElement.querySelector('#cancel-edit-tournament-modal-btn');
    const modalForm = modalElement.querySelector('#edit-tournament-form');
    const addParticipantsBtn = modalElement.querySelector('#modal-add-participants-btn'); // <-- Get reference to the new button

    // Use the *specific* close function which now calls the generic one
    if(closeButton) closeButton.addEventListener('click', closeEditTournamentModal);
    if(cancelButton) cancelButton.addEventListener('click', closeEditTournamentModal);
    // Form submission handler remains specific
    if(modalForm) modalForm.addEventListener('submit', handleEditTournamentSubmit);

    // Add listener for the new Add Participants button <-- ADD THIS
    if (addParticipantsBtn) {
        addParticipantsBtn.addEventListener('click', () => {
            // Call the function that opens the separate modal for managing participants
            openAddParticipantsModal(tournamentData.id);
            // Optionally close the edit modal first if you don't want both open
            // closeEditTournamentModal();
        });
    }

    // Call the generic openModal function to show the modal
    openModal(modalElement);
}
// --- End Tournament Edit Modal Functions (Refactored) ---

// --- Tournament Edit Modal Functions (Refactored for Generic Modal) ---
function closeEditTournamentModal() {
           // Get the specific modal container element
           const modalElement = document.getElementById('edit-tournament-modal');
           if (!modalElement) {
                console.error("Edit Tournament modal element (#edit-tournament-modal) not found when trying to close.");
                return;
           }

           // Call the generic closeModal function.
           // It handles hiding the modal, restoring scroll, and clearing the innerHTML
           // because 'edit-tournament-modal' is included in the 'modalsToClear' array within closeModal.
           closeModal(modalElement);

           // Also clear the temporarily stored tournament data after closing
           currentTournamentData = null;
       }
       // --- End Tournament Edit Modal Functions (Refactored) ---

async function handleEditTournamentSubmit(event) {
    event.preventDefault();
    const form = event.target;
    const tournamentId = form.getAttribute('data-tournament-id');
    if (!db || !tournamentId) { alert("Error: DB or Tournament ID missing."); return; }

    const formData = new FormData(form);
    const updatedData = {
        name: formData.get('tournament-name')?.trim(),
        format: formData.get('tournament-format'),
        status: formData.get('tournament-status'),
        last_updated: firebase.firestore.FieldValue.serverTimestamp()
    };

    // Handle optional date
    const startDateValue = formData.get('tournament-start-date');
    if (startDateValue) {
         try {
             const dateObj = new Date(startDateValue + 'T12:00:00Z'); // Use UTC midday
             if (isNaN(dateObj.getTime())) throw new Error("Invalid date");
             updatedData.start_date = firebase.firestore.Timestamp.fromDate(dateObj);
         } catch(e) {
             alert("Invalid Start Date entered."); return;
         }
    } else {
         updatedData.start_date = null; // Set to null if empty
    }

     // Basic Validation
     if (!updatedData.name || !updatedData.format || !updatedData.status) {
         alert("Please fill out Name, Format, and Status."); return;
     }
    console.log(`[EDIT TOURNAMENT] Submitting update for ${tournamentId}:`, updatedData);

    try {
        await db.collection('tournaments').doc(tournamentId).update(updatedData);
        alert("Tournament updated successfully!");
        closeEditTournamentModal();
        // Refresh the details view with the new data
        populateTournamentDetails(tournamentId);
         // Also refresh main tournament lists
         await populateTournamentsList('dashboard-tournaments-list', 3);
         await populateTournamentsList('tournaments-list-full');
    } catch (error) {
         console.error("Error updating tournament:", error);
         alert(`Failed to update tournament: ${error.message}`);
    }
}

// --- Handler for clicking Delete button on Detail Page ---
async function handleDeleteTournamentDetail(tournamentId) {
    console.log(`[DELETE TOURNAMENT DETAIL] Requesting delete for ID: ${tournamentId}`);
    if (!db || !tournamentId) { alert("Error: DB or Tournament ID missing."); return; }

    // Use the existing handleDeleteTournament function, but navigate away afterwards
    if (confirm(`Are you sure you want to delete this tournament (${tournamentId})? This cannot be undone.`)) {
         try {
             await db.collection('tournaments').doc(tournamentId).delete();
             console.log(`[FIRESTORE] Firestore document deleted: tournaments/${tournamentId}`);
             alert(`Tournament deleted.`);
             // Refresh main tournament lists
             await populateTournamentsList('dashboard-tournaments-list', 3);
             await populateTournamentsList('tournaments-list-full');
             // Navigate back to the main tournaments list
             showSection('tournaments-section');
         } catch (error) {
             console.error("Error deleting tournament:", error);
             alert(`Failed to delete tournament ${tournamentId}. See console for details.`);
         }
     }
}

// --- Handler for clicking Edit button on Detail Page ---
async function handleEditTournamentDetail(tournamentId) {
    console.log(`[EDIT TOURNAMENT DETAIL] Requesting edit for ID: ${tournamentId}`);
    if (!db || !tournamentId) { alert("Error: DB or Tournament ID missing."); return; }

    try {
        // Fetch current data first
        const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
        if (!tournamentDoc.exists) { throw new Error("Tournament data not found for editing."); }
        const tournamentData = { id: tournamentDoc.id, ...tournamentDoc.data() };
        // Open the edit modal with the fetched data
        openEditTournamentModal(tournamentData);
    } catch(error) {
         console.error("Error fetching tournament data for edit:", error);
         alert(`Error loading tournament details for editing: ${error.message}`);
    }
}

        // Updates player documents with Elo and Stats using a batch write
        async function updatePlayerElosAndStats(combinedUpdates) {
             if (!db || Object.keys(combinedUpdates).length === 0) {
                 console.warn("[ELO/STATS Update] No updates to apply or DB not connected.");
                 return;
             }
             console.log("[ELO/STATS Update] Starting batch update:", combinedUpdates);
             const batch = db.batch(); // Create a new batch

             // Iterate through the updates object (keyed by player ID)
             Object.entries(combinedUpdates).forEach(([playerId, updates]) => {
                 if (playerId && typeof updates === 'object' && updates !== null && Object.keys(updates).length > 0) {
                     const playerRef = db.collection('players').doc(playerId);
                     // Add an update operation to the batch for this player
                     batch.update(playerRef, updates);
                     console.log(`[ELO/STATS Update] Adding update for ${playerId}:`, updates);
                 } else {
                     console.warn(`[ELO/STATS Update] Skipping invalid update entry for player ID: ${playerId}`, updates);
                 }
             });

             try {
                 // Commit the batch write to Firestore
                 await batch.commit();
                 console.log("[FIRESTORE] Batch Elo/Stat update committed successfully.");
             } catch (error) {
                 console.error("[FIRESTORE] Batch Elo/Stat update failed:", error);
                 alert(`Failed to update player ratings/stats: ${error.message}`);
                 // Optionally re-throw the error if higher-level handling is needed
                 // throw error;
             }
        }
        // --- End Elo Functions ---



        let timerInterval = null;
        let timerSeconds = 0;
        let timerRunning = false;
        let countdownStartSeconds = 0;

        function updateTimerDisplay() {
            const display = document.getElementById('timer-display');
            if (!display) return;
            const minutes = Math.floor(timerSeconds / 60);
            const seconds = timerSeconds % 60;
            display.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function startTimer() {
            if (timerRunning) return;
            timerRunning = true;
            const mode = document.querySelector('input[name="timer-mode"]:checked')?.value || 'up';

            if (mode === 'down' && timerSeconds <= 0) {
                 const minutesInput = document.getElementById('timer-start-minutes');
                 countdownStartSeconds = (parseInt(minutesInput?.value, 10) || 10) * 60;
                 timerSeconds = countdownStartSeconds;
                 if (timerSeconds <= 0) {
                     alert("Please set a valid countdown time.");
                     timerRunning = false;
                     return;
                 }
            }

            updateTimerDisplay(); // Show initial time

            timerInterval = setInterval(() => {
                if (mode === 'up') {
                    timerSeconds++;
                } else { // Count down
                    timerSeconds--;
                    if (timerSeconds < 0) {
                        clearInterval(timerInterval);
                        timerRunning = false;
                        timerSeconds = 0;
                        alert("Time's up!");
                        // Add sound effect here if desired (using Tone.js or similar)
                    }
                }
                updateTimerDisplay();
            }, 1000);
        }

        function pauseTimer() {
            clearInterval(timerInterval);
            timerRunning = false;
        }

        function resetTimer() {
            clearInterval(timerInterval);
            timerRunning = false;
            const mode = document.querySelector('input[name="timer-mode"]:checked')?.value || 'up';
            timerSeconds = (mode === 'down' && countdownStartSeconds > 0) ? countdownStartSeconds : 0;
            updateTimerDisplay();
        }

        function nextTurn() {
            // Placeholder for turn-based timer logic (e.g., reset turn timer, switch player)
            console.log("Next Turn clicked");
             alert("Turn logic not fully implemented.");
             // Could potentially reset a separate 'turnTimerSeconds' variable here
        }

        function rollDice() {
            const diceResultEl = document.getElementById('dice-result');
            if (!diceResultEl) return;
            const roll = Math.floor(Math.random() * 6) + 1;
            // Simple emoji display
            const diceFaces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ']; // Unicode dice
            diceResultEl.textContent = diceFaces[roll - 1];
        }

        function openSubmitScoreFormFromLive() {
            // This function would likely pre-fill the "Submit Past Game" form
            // with data gathered during the live session (players, maybe score)
            // and then navigate the user to that section.
            console.log("Submit Final Score from Live Game clicked");
            alert("Transition to final score submission not implemented yet.");
            // Example:
            // const player1Score = document.getElementById('score-p1').value;
            // const player2Score = document.getElementById('score-p2').value;
            // Pre-fill form elements in #submit-past-game-section
            // showSection('submit-past-game-section');
        }


        // --- Submit Past Game Section Logic ---
        function setupSubmitPastGameListeners() {
             const form = document.getElementById('submit-past-game-form');
             form?.addEventListener('submit', handleSubmitPastGame);

             // Populate dropdowns when the section becomes visible (or on init)
             // Needs player and game type data
             const gameTypeSelect = form?.querySelector('#past-game-type');
             const winnerSelect = form?.querySelector('#past-winner');
             const loserSelect = form?.querySelector('#past-loser');
             const drawCheckbox = form?.querySelector('#past-is-draw');
             const winnerLabel = form?.querySelector('label[for="past-winner"]');
             const loserLabel = form?.querySelector('label[for="past-loser"]');

             if (gameTypeSelect) populateSelectWithOptions(gameTypeSelect, gameTypesConfig, 'Select Game Type');
             // Player dropdowns need the player list (use global cache or fetch)
             if (winnerSelect && loserSelect && globalPlayerCache) {
                 const playersArray = Object.values(globalPlayerCache);
                 populatePlayerDropdown(winnerSelect, playersArray, 'Select Winner');
                 populatePlayerDropdown(loserSelect, playersArray, 'Select Loser');
             }

            // Listener for draw checkbox
            drawCheckbox?.addEventListener('change', (e) => {
                 if (winnerLabel && loserLabel) {
                    winnerLabel.textContent = e.target.checked ? 'Player 1:' : 'Winner:';
                    loserLabel.textContent = e.target.checked ? 'Player 2:' : 'Loser:';
                 }
            });
        }

        async function handleSubmitPastGame(event) {
            event.preventDefault();
            const form = event.target;
            console.log("Submit Past Game form submitted.");
            if (!db) { alert("Database connection error."); return; }

            // --- Validation (Similar to Record Game Modal) ---
            let isValid = true;
            const gameType = form.querySelector('#past-game-type').value;
            const winnerId = form.querySelector('#past-winner').value;
            const loserId = form.querySelector('#past-loser').value;
            const isDraw = form.querySelector('#past-is-draw').checked;
            const score = form.querySelector('#past-score').value.trim() || null;
            const datePlayedValue = form.querySelector('#past-date-played').value;

            // Reset previous errors
            form.querySelectorAll('.border-red-500').forEach(el => el.classList.remove('border-red-500'));

            if (!gameType) { form.querySelector('#past-game-type').classList.add('border-red-500'); isValid = false; }
            if (!winnerId) { form.querySelector('#past-winner').classList.add('border-red-500'); isValid = false; }
            if (!loserId) { form.querySelector('#past-loser').classList.add('border-red-500'); isValid = false; }
            if (!datePlayedValue) { form.querySelector('#past-date-played').classList.add('border-red-500'); isValid = false; }
            if (!isDraw && winnerId && loserId && winnerId === loserId) {
                 alert("Winner and Loser cannot be the same unless it's a draw.");
                 form.querySelector('#past-winner').classList.add('border-red-500');
                 form.querySelector('#past-loser').classList.add('border-red-500');
                 isValid = false;
            }
            if (!isValid) { alert("Please fill in all required fields correctly."); return; }
            // --- End Validation ---

            // Convert date string to Firebase Timestamp
            let firestoreDate;
            try {
                 const dateObj = new Date(datePlayedValue + 'T12:00:00Z');
                 if (isNaN(dateObj.getTime())) throw new Error("Invalid date");
                 firestoreDate = firebase.firestore.Timestamp.fromDate(dateObj);
            } catch(e) {
                 alert("Invalid Date Played format.");
                 form.querySelector('#past-date-played').classList.add('border-red-500');
                 return;
            }

            // Prepare game data object
            const gameData = {
                game_type: gameType,
                date_played: firestoreDate,
                score: score,
                outcome: isDraw ? 'Draw' : 'Win/Loss',
                participants: isDraw ? [winnerId, loserId].sort() : [winnerId, loserId],
                // Add any other relevant fields (e.g., recorded_by: currentPlayer.id)
            };

             console.log("Past Game Data to save:", gameData);

            try {
                // --- Elo/Stat Calculation (reuse existing logic) ---
                let eloUpdates = {};
                const FieldValue = firebase.firestore.FieldValue;
                const player1StatUpdates = { games_played: FieldValue.increment(1) };
                const player2StatUpdates = { games_played: FieldValue.increment(1) };

                // Check if the game type uses Elo rating
                if (ELO_GAME_KEYS.includes(gameType)) {
                    if (!isDraw) {
                        eloUpdates = await calculateEloUpdate(winnerId, loserId, gameType);
                        player1StatUpdates.wins = FieldValue.increment(1);
                        player2StatUpdates.losses = FieldValue.increment(1);
                    } else {
                        eloUpdates = await calculateEloUpdateDraw(winnerId, loserId, gameType);
                        player1StatUpdates.draws = FieldValue.increment(1);
                        player2StatUpdates.draws = FieldValue.increment(1);
                    }
                } else { // Non-Elo game (just track win/loss/draw)
                    if (!isDraw) {
                        player1StatUpdates.wins = FieldValue.increment(1);
                        player2StatUpdates.losses = FieldValue.increment(1);
                    } else {
                        player1StatUpdates.draws = FieldValue.increment(1);
                        player2StatUpdates.draws = FieldValue.increment(1);
                    }
                }
                // Combine updates
                const finalUpdates = {};
                const p1Id = winnerId; const p2Id = loserId;
                if (p1Id && (eloUpdates[p1Id] || Object.keys(player1StatUpdates).length > 0)) { finalUpdates[p1Id] = { ...(eloUpdates[p1Id] || {}), ...player1StatUpdates }; }
                if (p2Id && (eloUpdates[p2Id] || Object.keys(player2StatUpdates).length > 0)) { finalUpdates[p2Id] = { ...(eloUpdates[p2Id] || {}), ...player2StatUpdates }; }

                // --- Save to Firestore ---
                const docRef = await db.collection('games').add(gameData);
                console.log("Past game saved with ID:", docRef.id);
                if (Object.keys(finalUpdates).length > 0) {
                    await updatePlayerElosAndStats(finalUpdates);
                    console.log("Player stats/elos updated.");
                }

                alert("Past game submitted successfully!");
                form.reset(); // Clear the form

                // --- Navigate to Game Info Screen ---
                populateGameInfoScreen(docRef.id, gameData); // Pass ID and data
                showSection('game-info-section');

                // Refresh other relevant sections in the background
                populateResultsTable();
                populateDashboard();
                // Optionally refresh rankings if visible
                if (document.getElementById('rankings-section') && !document.getElementById('rankings-section').classList.contains('hidden')) {
                     updateRankingsVisibility();
                }

            } catch (error) {
                console.error("Error submitting past game:", error);
                alert(`Error: ${error.message}`);
            }
        }


        // --- Game Info Screen Logic ---
        function setupGameInfoListeners() {
            document.getElementById('share-game-info-btn')?.addEventListener('click', shareGameInfo);
        }

        async function populateGameInfoScreen(gameId, gameData) {
            const contentEl = document.getElementById('game-info-content');
            if (!contentEl) return;

            contentEl.innerHTML = '<p class="text-gray-500">Loading game details...</p>'; // Loading state

            // Use gameData passed directly if available, otherwise fetch
            let finalGameData = gameData;
            if (!finalGameData && gameId && db) {
                 try {
                    const docSnap = await db.collection('games').doc(gameId).get();
                    if (docSnap.exists) {
                        finalGameData = { id: docSnap.id, ...docSnap.data() };
                    } else {
                        throw new Error("Game not found");
                    }
                 } catch (err) {
                     console.error("Error fetching game info:", err);
                     contentEl.innerHTML = `<p class="text-red-500">Error loading game details: ${err.message}</p>`;
                     return;
                 }
            } else if (!finalGameData) {
                 contentEl.innerHTML = `<p class="text-red-500">Error: Could not load game details.</p>`;
                 return;
            }


            // Format data for display (reuse logic from results table population if possible)
            const gameTypeDisplay = gameTypesConfig[finalGameData.game_type] || finalGameData.game_type || 'N/A';
            const gameDateStr = finalGameData.date_played?.toDate ? finalGameData.date_played.toDate().toLocaleDateString() : 'N/A';
            let description = '';
            let playersHtml = '';

            // Ensure player cache is populated
            if (!playersCachePopulated) await fetchAllPlayersForCache();

            const participants = finalGameData.participants || [];
            const participantNames = participants.map(id => globalPlayerCache[id]?.name || 'Unknown Player');

            if (finalGameData.game_type === 'golf' && participantNames.length > 0) {
                 description = `<b>${participantNames[0]}</b> played ${gameTypeDisplay}`;
                 playersHtml = `<p><strong>Player:</strong> ${participantNames[0]}</p>`;
                 // Add course info if available
            } else if (finalGameData.outcome === 'Win/Loss' && participantNames.length >= 2) {
                 description = `<b>${participantNames[0]}</b> defeated ${participantNames[1]} in ${gameTypeDisplay}`;
                 playersHtml = `<p><strong>Winner:</strong> ${participantNames[0]}</p><p><strong>Loser:</strong> ${participantNames[1]}</p>`;
            } else if (finalGameData.outcome === 'Draw' && participantNames.length >= 2) {
                 description = `${participantNames[0]} drew with ${participantNames[1]} in ${gameTypeDisplay}`;
                 playersHtml = `<p><strong>Player 1:</strong> ${participantNames[0]}</p><p><strong>Player 2:</strong> ${participantNames[1]}</p>`;
            } else {
                 description = `Game of ${gameTypeDisplay} played`;
                 playersHtml = `<p><strong>Participants:</strong> ${participantNames.join(', ')}</p>`;
            }

            // Build HTML
            contentEl.innerHTML = `
                <h2 class="text-2xl font-semibold mb-4">${description}</h2>
                <p class="mb-2"><strong>Date:</strong> ${gameDateStr}</p>
                ${playersHtml}
                ${finalGameData.score ? `<p class="mb-2"><strong>Score:</strong> ${finalGameData.score}</p>` : ''}
                <p class="text-xs text-gray-400 mt-4">Game ID: ${finalGameData.id || gameId}</p>
            `;

            // Store game ID for sharing
            contentEl.setAttribute('data-game-id-for-share', finalGameData.id || gameId);
        }

        function shareGameInfo() {
            const contentEl = document.getElementById('game-info-content');
            const gameId = contentEl?.getAttribute('data-game-id-for-share');
            if (navigator.share && gameId) {
                 const shareUrl = `${window.location.origin}${window.location.pathname}#game-info-section?gameId=${gameId}`; // Basic share URL structure
                 navigator.share({
                     title: 'LeaderBored Game Result',
                     text: `Check out this game result on LeaderBored!`,
                     url: shareUrl,
                 })
                 .then(() => console.log('Successful share'))
                 .catch((error) => console.log('Error sharing', error));
            } else if (gameId) {
                 // Fallback for browsers that don't support Web Share API
                 const shareUrl = `${window.location.origin}${window.location.pathname}#game-info-section?gameId=${gameId}`;
                 prompt("Copy this link to share:", shareUrl);
            } else {
                 alert("Could not get game details to share.");
            }
        }

        // --- REPLACE existing showSection function with this modified version ---
        async function showSection(targetId) {
             if (!sections) { console.error("Sections variable is not assigned yet in showSection"); return; }
             console.log(`[NAV] Navigating to: ${targetId}`);
            const cleanTargetId = targetId.startsWith('#') ? targetId.substring(1) : targetId;
            let sectionFound = false;

            sections.forEach(section => {
                if (section && section.id) section.classList.add('hidden');
            });

            const targetSection = document.getElementById(cleanTargetId);
            if (targetSection && targetSection.classList.contains('page-section')) {
                console.log(`[NAV] Showing section: ${targetSection.id}`);
                targetSection.classList.remove('hidden');
                sectionFound = true;

                 // --- NEW: Check for Game Info Section and Query Param ---
                 if (cleanTargetId === 'game-info-section') {
                    const urlParams = new URLSearchParams(window.location.search); // Check query params first
                    let gameId = urlParams.get('gameId');
                    if (!gameId) { // If not in query, check hash (less ideal)
                        const hashParts = window.location.hash.split('?gameId=');
                        if (hashParts.length > 1) gameId = hashParts[1];
                    }
                    if (gameId) {
                        console.log(`[NAV] Found gameId parameter: ${gameId}. Populating game info.`);
                        await populateGameInfoScreen(gameId, null); // Fetch data using ID
                    } else {
                        console.log("[NAV] Navigated to game info section without a gameId.");
                        // Optionally clear the content or show a default message
                        document.getElementById('game-info-content').innerHTML = '<p class="text-gray-500">No specific game selected.</p>';
                    }
                 }
                 // --- END NEW CHECK ---


                // Populate content if DB is ready
                if (db) {
                    // --- Ensure Cache is Ready for Relevant Sections ---
                    const needsCache = ['home-section', 'results-section', 'players-section', 'rankings-section', 'submit-past-game-section']; // Added submit-past-game
                    if (needsCache.includes(cleanTargetId) && !playersCachePopulated) {
                        console.warn(`[NAV] Player cache not ready for ${cleanTargetId}, attempting population...`);
                        await fetchAllPlayersForCache();
                        if (!playersCachePopulated) {
                             console.error(`[NAV] Failed to populate cache before showing ${cleanTargetId}. Section content may be incomplete.`);
                             if(targetSection) targetSection.innerHTML = `<p class="text-red-500 p-4 text-center">Error: Could not load required player data.</p>`;
                        }
                    }
                    // --- End Cache Check ---

                    // Populate Section Content (Make calls async with await)
                    if (playersCachePopulated || !needsCache.includes(cleanTargetId)) {
                        if (cleanTargetId === 'home-section') await populateDashboard();
                        if (cleanTargetId === 'rankings-section' && rankingTablesContainer) {
                            updateGameTypeDropdowns();
                            await updateRankingsVisibility();
                        }
                        if (cleanTargetId === 'results-section' && resultsTableBody) await populateResultsTable();
                        if (cleanTargetId === 'players-section' && playersGrid) await populatePlayersList();
                        if (cleanTargetId === 'tournaments-section' && document.getElementById('tournaments-list-full')) await populateTournamentsList('tournaments-list-full');
                        // --- NEW: Setup Listeners/Populate for new sections ---
                        
                        if (cleanTargetId === 'submit-past-game-section') setupSubmitPastGameListeners(); // Setup listeners & populate dropdowns
                        if (cleanTargetId === 'game-info-section') setupGameInfoListeners(); // Setup share button listener
                        // --- END NEW ---
                    } else if (needsCache.includes(cleanTargetId)) {
                         console.error(`[NAV] Cannot populate ${cleanTargetId} because player cache failed to load.`);
                    }

                } else {
                    console.warn(`[NAV] DB not ready, skipping population for section ${cleanTargetId}`);
                }

            } else {
                 console.warn(`[NAV] Section with ID "${cleanTargetId}" not found or invalid. Showing home.`);
                 const homeSection = document.getElementById('home-section');
                 if (homeSection) {
                     homeSection.classList.remove('hidden');
                     if (db) {
                          if(!playersCachePopulated) await fetchAllPlayersForCache();
                          if(playersCachePopulated) await populateDashboard();
                          else console.error("[NAV] Cannot populate home section because player cache failed to load.");
                     }
                 } else {
                     console.error("Critical Error: Home section (#home-section) not found as fallback.");
                 }
            }

            if (sectionFound) {
                 // Update hash, removing query params if they exist to avoid confusion
                 window.location.hash = cleanTargetId;
                 window.scrollTo(0, 0); // Scroll to top
            }
        }


// --- REPLACE existing initializeApp function with this modified version ---
async function initializeApp() {
            try {
                console.log("[INIT] Initializing App...");
                assignElements();
                if (!db || !auth) {
                    console.error("[INIT] Firebase DB or Auth connection failed."); return;
                }

                await fetchAllPlayersForCache(); // Wait for cache

                updateGameTypeDropdowns();
                setupEventListeners(); // General listeners setup FIRST

                // ***** ADD THIS LINE HERE *****
                setupLiveGameSection(); // Setup listeners specific to the live game section controls (like the game select dropdown)
                // ***** END OF ADDED LINE *****

                // --- Auth Listener (Keep as is) ---
                auth.onAuthStateChanged(async (user) => {
                    // ... existing auth logic ...
                    const loginButton = document.getElementById('player-login-link');
                    const profileSection = document.getElementById('profile-section');
                    const profileImg = document.getElementById('profile-photo-img');

                    // Clear admin state first
                    document.body.classList.remove('player-logged-in');
                    document.body.classList.remove('admin-logged-in'); // Remove admin class initially
                    currentPlayer = null; // Reset current player

                    if (user) {
                        // Player is signed in.
                        console.log("Auth State Changed: User is logged in", user.uid);
                        document.body.classList.add('player-logged-in'); // Mark as player logged in

                        currentPlayer = await getPlayerProfileByAuthId(user.uid);

                        if (currentPlayer) {
                            console.log("Current player data:", currentPlayer);

                            // ---> CHECK FOR ADMIN <---
                            if (currentPlayer.isAdmin === true) {
                                console.log("User is an Admin.");
                                document.body.classList.add('admin-logged-in'); // Add admin class to body
                            } else {
                                console.log("User is NOT an Admin.");
                            }
                            // ---> END CHECK <---

                            // Update profile photo
                            const photoURL = currentPlayer.iconUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(currentPlayer.name || '?')}&background=E0E7FF&color=4F46E5&size=40`;
                            if (profileImg) profileImg.src = photoURL;

                        } else {
                            console.warn("Logged in user has no associated player profile!", user.uid);
                            if (profileImg) profileImg.src = 'https://ui-avatars.com/api/?name=?&background=E0E7FF&color=4F46E5&size=40'; // Default icon
                            currentPlayer = { authUid: user.uid, email: user.email, name: "Profile Needed", isAdmin: false }; // Assume not admin
                        }

                        // Navigate away from login/register if needed
                        if (window.location.hash === '#player-login-section' || window.location.hash === '#register-section') {
                            await showSection('home-section');
                        }

                    } else {
                        // Player is signed out.
                        console.log("Auth State Changed: User is logged out");
                        document.getElementById('profile-dropdown')?.classList.add('hidden'); // Ensure dropdown is hidden
                    }
                });
                // --- END AUTH LISTENER ---

                // Handle initial page load
                // Separate hash and query parameters for cleaner handling
                const hash = window.location.hash.split('?')[0]; // Get part before '?'
                const initialHash = hash || '#home-section'; // Default to home if no hash
                let initialSectionId = 'home-section';

                if (initialHash && initialHash !== '#') {
                    const targetIdFromHash = initialHash.substring(1);
                    const targetSection = document.getElementById(targetIdFromHash);
                    if (targetSection?.classList.contains('page-section')) {
                        initialSectionId = targetIdFromHash;
                    } else {
                        console.warn(`[INIT] Hash '#${targetIdFromHash}' does not correspond to a valid section. Defaulting to home.`);
                    }
                }

                // Show the initial section AFTER setting up the auth listener and other section listeners
                await showSection(initialSectionId); // showSection now handles the gameId param check

                console.log("[INIT] App Initialized Successfully.");
            } catch (error) {
                console.error("Error during app initialization:", error);
                alert(`An error occurred while initializing the application: ${error.message}. Please check the console.`);
            }
        }

// --- Run Initialization on DOM Load ---
// (Keep this part as it is)
document.addEventListener('DOMContentLoaded', initializeApp);
    
 
// --- End Dark Mode Toggle Logic ---
    </script>
<div class="fixed bottom-5 right-5 z-50">
    <label for="dark-toggle" class="flex items-center cursor-pointer">
      <div class="relative">
        <input type="checkbox" id="dark-toggle" class="sr-only">
        <div class="block bg-gray-600 w-14 h-8 rounded-full"></div>
        <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition"></div>
      </div>
      <div class="ml-3 text-gray-700 font-medium text-sm dark:text-gray-300">
        Dark Mode
      </div>
    </label>
  </div>
  <script>
   // --- Dark Mode Toggle Logic ---
   const darkModeToggle = document.getElementById('dark-toggle');
const bodyElement = document.body;

// Function to apply the theme based on toggle state
const applyTheme = (isDark) => {
  if (isDark) {
    bodyElement.classList.add('dark');
  } else {
    bodyElement.classList.remove('dark');
  }
};

// Check localStorage for saved theme preference
const savedTheme = localStorage.getItem('theme');
if (savedTheme) {
  const isDark = savedTheme === 'dark';
  darkModeToggle.checked = isDark;
  applyTheme(isDark);
} else {
  // Optional: Check for system preference if no explicit choice saved
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  darkModeToggle.checked = prefersDark;
  applyTheme(prefersDark);
}


// Add event listener for the toggle
darkModeToggle.addEventListener('change', () => {
  const isDark = darkModeToggle.checked;
  applyTheme(isDark);
  // Save the preference to localStorage
  localStorage.setItem('theme', isDark ? 'dark' : 'light');
});

// Optional: Listen for system theme changes
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
   // Only apply system preference if no user preference is stored
   if (!localStorage.getItem('theme')) {
       const isDark = event.matches;
       darkModeToggle.checked = isDark;
       applyTheme(isDark);
   }
});


  </script>
</body>
</html>
